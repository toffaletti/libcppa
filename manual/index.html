<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.00">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding 0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
body{width:600px;margin:auto;padding-top:20px;text-align: justify;}
</style>
<title>libcppa 
  
An implementation of the actor model for C++ 
  
  
  
User Manual 
libcppa version 0.5
</title>
</head>
<body >
<!--HEVEA command line is: hevea -I .. manual.tex -->
<!--CUT STYLE article--><!--CUT DEF section 1 --><table class="title"><tr><td><h1 class="titlemain"><span style="font-family:monospace"><span style="font-size:xx-large"><span style="font-weight:bold">libcppa</span></span></span><br>
 <br>
An implementation of the actor model for C++<br>
 <br>
 <br>
 <br>
User Manual<br>
<span style="font-family:monospace">libcppa</span> version 0.5</h1><h3 class="titlerest">Dominik Charousset</h3></td></tr>
</table><!--TOC section id=sec1 Contents-->
<h2 id="sec1" class="section">Contents</h2><!--SEC END --><ul class="toc"><li class="li-toc">
<a href="#sec2">1  First Steps</a>
<ul class="toc"><li class="li-toc">
<a href="#sec3">1.1  Features Overview</a>
</li><li class="li-toc"><a href="#sec4">1.2  Supported Compilers</a>
</li><li class="li-toc"><a href="#sec5">1.3  Supported Operating Systems</a>
</li><li class="li-toc"><a href="#sec6">1.4  Hello World Example</a>
</li></ul>
</li><li class="li-toc"><a href="#sec7">2  Copy-On-Write Tuples</a>
<ul class="toc"><li class="li-toc">
<a href="#sec8">2.1  Dynamically Typed Tuples</a>
</li><li class="li-toc"><a href="#sec9">2.2  Casting Tuples</a>
</li></ul>
</li><li class="li-toc"><a href="#sec10">3  Pattern Matching</a>
<ul class="toc"><li class="li-toc">
<a href="#sec11">3.1  Basics</a>
</li><li class="li-toc"><a href="#sec12">3.2  Atoms</a>
</li><li class="li-toc"><a href="#sec13">3.3  Reducing Redundancy with “<code>arg_match</code>” and “<code>on_arg_match</code>”</a>
</li><li class="li-toc"><a href="#sec14">3.4  Wildcards</a>
</li><li class="li-toc"><a href="#sec15">3.5  Guards</a>
<ul class="toc"><li class="li-toc">
<a href="#sec16">3.5.1  Placeholder Interface</a>
</li><li class="li-toc"><a href="#sec17">3.5.2  Examples for Guard Expressions</a>
</li></ul>
</li><li class="li-toc"><a href="#sec18">3.6  Projections and Extractors</a>
</li></ul>
</li><li class="li-toc"><a href="#sec19">4  Actors</a>
<ul class="toc"><li class="li-toc">
<a href="#sec20">4.1  Local Actors</a>
<ul class="toc"><li class="li-toc">
<a href="#sec21">4.1.1  “Keyword” <span style="font-family:monospace">self</span></a>
</li><li class="li-toc"><a href="#sec22">4.1.2  Interface</a>
</li></ul>
</li><li class="li-toc"><a href="#sec23">4.2  Types of Actors</a>
<ul class="toc"><li class="li-toc">
<a href="#sec24">4.2.1  Thread-Mapped Actors</a>
</li><li class="li-toc"><a href="#sec25">4.2.2  Context-Switching Actors</a>
</li><li class="li-toc"><a href="#sec26">4.2.3  Event-Based Actors</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec27">5  Sending Messages</a>
<ul class="toc"><li class="li-toc">
<a href="#sec28">5.1  Replying to Messages</a>
</li><li class="li-toc"><a href="#sec29">5.2  Chaining Sends</a>
</li><li class="li-toc"><a href="#sec30">5.3  Delaying Messages</a>
</li><li class="li-toc"><a href="#sec31">5.4  Forwarding Messages</a>
</li></ul>
</li><li class="li-toc"><a href="#sec32">6  Receiving Messages</a>
<ul class="toc"><li class="li-toc">
<a href="#sec33">6.1  Blocking API for Context-Switching and Thread-Mapped Actors</a>
</li><li class="li-toc"><a href="#sec34">6.2  Event-Based API</a>
<ul class="toc"><li class="li-toc">
<a href="#sec35">6.2.1  State-Based Actors</a>
</li><li class="li-toc"><a href="#sec36">6.2.2  Nesting Receives Using <code>become</code><code>/</code><code>unbecome</code></a>
</li><li class="li-toc"><a href="#sec37">6.2.3  Using a Factory to Define Event-Based Actors</a>
</li></ul>
</li><li class="li-toc"><a href="#sec38">6.3  Timeouts</a>
</li></ul>
</li><li class="li-toc"><a href="#sec39">7  Synchronous Communication</a>
<ul class="toc"><li class="li-toc">
<a href="#sec40">7.1  Receive Response Messages</a>
</li><li class="li-toc"><a href="#sec41">7.2  Using <code>message_future</code>’s Member Functions to Receive a Response</a>
</li></ul>
</li><li class="li-toc"><a href="#sec42">8  Management</a>
<ul class="toc"><li class="li-toc">
<a href="#sec43">8.1  Links</a>
</li><li class="li-toc"><a href="#sec44">8.2  Monitors</a>
</li><li class="li-toc"><a href="#sec45">8.3  Error Codes</a>
</li><li class="li-toc"><a href="#sec46">8.4  Attach Cleanup Code to an Actor</a>
</li></ul>
</li><li class="li-toc"><a href="#sec47">9  Spawning Actors</a>
<ul class="toc"><li class="li-toc">
<a href="#sec48">9.1  Create Actors from Functors</a>
</li><li class="li-toc"><a href="#sec49">9.2  Create Class-Based Actors</a>
</li></ul>
</li><li class="li-toc"><a href="#sec50">10  Network Transparency</a>
<ul class="toc"><li class="li-toc">
<a href="#sec51">10.1  Publishing of Actors</a>
</li><li class="li-toc"><a href="#sec52">10.2  Connecting to Remote Actors</a>
</li></ul>
</li><li class="li-toc"><a href="#sec53">11  Group Communication</a>
<ul class="toc"><li class="li-toc">
<a href="#sec54">11.1  Anonymous Groups</a>
</li><li class="li-toc"><a href="#sec55">11.2  Local Groups</a>
</li><li class="li-toc"><a href="#sec56">11.3  Spawn Actors in Groups</a>
</li></ul>
</li><li class="li-toc"><a href="#sec57">12  Common Pitfalls</a>
<ul class="toc"><li class="li-toc">
<a href="#sec58">12.1  Event-Based API</a>
</li><li class="li-toc"><a href="#sec59">12.2  Mixing Event-Based and Blocking API</a>
</li><li class="li-toc"><a href="#sec60">12.3  Synchronous Messages</a>
</li><li class="li-toc"><a href="#sec61">12.4  Sending Messages</a>
</li><li class="li-toc"><a href="#sec62">12.5  Sharing</a>
</li></ul>
</li><li class="li-toc"><a href="#sec63">13  Platform-Independent Type System</a>
<ul class="toc"><li class="li-toc">
<a href="#sec64">13.1  User-Defined Data Types in Messages</a>
</li></ul>
</li><li class="li-toc"><a href="#sec65">14  Appendix</a>
<ul class="toc"><li class="li-toc">
<a href="#sec66">14.1  Class <code>option</code></a>
</li></ul>
</li></ul>
<!--TOC section id=sec2 First Steps-->
<h2 id="sec2" class="section">1  First Steps</h2><!--SEC END --><p>To compile <span style="font-family:monospace">libcppa</span>, you will need CMake, the Boost Library and a C++11 compiler. To get and compile the sources, open a terminal and type:</p><pre class="verbatim">git clone git://github.com/Neverlord/libcppa.git
cd libcppa
./configure
make
make install [as root, optional]
</pre><p>It is recommended to run the unit tests as well:</p><pre class="verbatim">make test
</pre><p>Please submit a bug report that includes (a) your compiler version, (b) your OS, and (c) the content of the file <span style="font-family:monospace">build/Testing/Temporary/LastTest.log</span> if an error occurs.</p>
<!--TOC subsection id=sec3 Features Overview-->
<h3 id="sec3" class="subsection">1.1  Features Overview</h3><!--SEC END --><ul class="itemize"><li class="li-itemize">
Lightweight, fast and efficient actor implementations
</li><li class="li-itemize">Network transparent messaging
</li><li class="li-itemize">Error handling based on Erlang’s failure model
</li><li class="li-itemize">Pattern matching for messages as internal DSL to ease development
</li><li class="li-itemize">Thread-mapped actors and on-the-fly conversions for soft migration of existing applications
</li><li class="li-itemize">Group communication based on Publish/Subscribe
</li></ul>
<!--TOC subsection id=sec4 Supported Compilers-->
<h3 id="sec4" class="subsection">1.2  Supported Compilers</h3><!--SEC END --><ul class="itemize"><li class="li-itemize">
GCC ≥ 4.7
</li><li class="li-itemize">Clang ≥ 3.2
</li></ul>
<!--TOC subsection id=sec5 Supported Operating Systems-->
<h3 id="sec5" class="subsection">1.3  Supported Operating Systems</h3><!--SEC END --><ul class="itemize"><li class="li-itemize">
Linux
</li><li class="li-itemize">Mac OS X
</li><li class="li-itemize"><span style="font-style:italic">Note for MS Windows</span>:
<span style="font-family:monospace">libcppa</span> relies on C++11 features such as variadic templates.
We will support this platform as soon as Microsoft’s compiler implements all required C++11 features.
</li></ul>
<!--TOC subsection id=sec6 Hello World Example-->
<h3 id="sec6" class="subsection">1.4  Hello World Example</h3><!--SEC END --><div class="lstlisting"><span style="font-size:small"><span style="color:blue">#include</span></span><span style="font-size:small"> &lt;</span><span style="font-size:small">string</span><span style="font-size:small">&gt;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">#include</span></span><span style="font-size:small"> &lt;</span><span style="font-size:small">iostream</span><span style="font-size:small">&gt;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">#include</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"cppa/cppa.hpp"</span></span></span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">using</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">namespace</span></span><span style="font-size:small"> </span><span style="font-size:small">cppa</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">void</span></span><span style="font-size:small"> </span><span style="font-size:small">echo_actor</span><span style="font-size:small">() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// wait for a message</span></span></span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// invoke this lambda expression if we receive a string</span></span></span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">what</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// prints "Hello World!"</span></span></span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">cout</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">what</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">endl</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// replies "!dlroW olleH"</span></span></span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">reply</span><span style="font-size:small">(</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">(</span><span style="font-size:small">what</span><span style="font-size:small">.</span><span style="font-size:small">rbegin</span><span style="font-size:small">(), </span><span style="font-size:small">what</span><span style="font-size:small">.</span><span style="font-size:small">rend</span><span style="font-size:small">()));</span><span style="font-size:small">
</span><span style="font-size:small">        }</span><span style="font-size:small">
</span><span style="font-size:small">    );</span><span style="font-size:small">
</span><span style="font-size:small">}</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">main</span><span style="font-size:small">() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// create a new actor that invokes the function echo_actor</span></span></span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">hello_actor</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">(</span><span style="font-size:small">echo_actor</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// send "Hello World!" to our new actor</span></span></span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// note: libcppa converts string literals to std::string</span></span></span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">send</span><span style="font-size:small">(</span><span style="font-size:small">hello_actor</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"Hello World!"</span></span></span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// wait for a response and print it</span></span></span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">what</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// prints "!dlroW olleH"</span></span></span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">cout</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">what</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">endl</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">        }</span><span style="font-size:small">
</span><span style="font-size:small">    );</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// wait until all other actors we've spawned are done</span></span></span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">await_all_others_done</span><span style="font-size:small">();</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// done</span></span></span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">shutdown</span><span style="font-size:small">();</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:blue">return</span></span><span style="font-size:small"> 0;</span><span style="font-size:small">
</span><span style="font-size:small">}</span></div>
<!--TOC section id=sec7 Copy-On-Write Tuples-->
<h2 id="sec7" class="section">2  Copy-On-Write Tuples</h2><!--SEC END --><p>
<a id="Sec::Tuples"></a></p><p>The message passing implementation of <span style="font-family:monospace">libcppa</span> uses tuples with call-by-value semantic.
Hence, it is not necessary to declare message types, though, <span style="font-family:monospace">libcppa</span> allows users to use user-defined types in messages (see Section <a href="#Sec%3A%3ATypeSystem%3A%3AUserDefined">13.1</a>).
A call-by-value semantic would cause multiple copies of a tuple if it is send to multiple actors.
To avoid unnecessary copying overhead, <span style="font-family:monospace">libcppa</span> uses a copy-on-write tuple implementation.
A tuple is implicitly shared between any number of actors, as long as all actors demand only read access.
Whenever an actor demands write access, it has to copy the data first if more than one reference to it exist.
Thus, race conditions cannot occur and each tuple is copied only if necessary.</p><p>The interface of <code>cow_tuple</code> strictly distinguishes between const and non-const access.
The template function <code>get</code> returns an element as immutable value, while <code>get_ref</code> explicitly returns a mutable <span style="font-style:italic">reference</span> to the required value and detaches the tuple if needed.
We do not provide a const overload for <code>get</code>, because this would cause to unintended, and thus unnecessary, copying overhead.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">x1</span><span style="font-size:small"> = </span><span style="font-size:small">make_cow_tuple</span><span style="font-size:small">(1, 2, 3);     </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// cow_tuple&lt;int, int, int&gt;</span></span></span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">x2</span><span style="font-size:small"> = </span><span style="font-size:small">x1</span><span style="font-size:small">;                          </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// cow_tuple&lt;int, int, int&gt;</span></span></span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(&amp;</span><span style="font-size:small">get</span><span style="font-size:small">&lt;0&gt;(</span><span style="font-size:small">x1</span><span style="font-size:small">) == &amp;</span><span style="font-size:small">get</span><span style="font-size:small">&lt;0&gt;(</span><span style="font-size:small">x2</span><span style="font-size:small">));    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// point to the same data</span></span></span><span style="font-size:small">
</span><span style="font-size:small">get_ref</span><span style="font-size:small">&lt;0&gt;(</span><span style="font-size:small">x1</span><span style="font-size:small">) = 10;                   </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// detaches x1 from x2</span></span></span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">//get&lt;0&gt;(x1) = 10;                     // compiler error</span></span></span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">get</span><span style="font-size:small">&lt;0&gt;(</span><span style="font-size:small">x1</span><span style="font-size:small">) == 10);              </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// x1 is now {10, 2, 3}</span></span></span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">get</span><span style="font-size:small">&lt;0&gt;(</span><span style="font-size:small">x2</span><span style="font-size:small">) == 1);               </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// x2 is still {1, 2, 3}</span></span></span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(&amp;</span><span style="font-size:small">get</span><span style="font-size:small">&lt;0&gt;(</span><span style="font-size:small">x1</span><span style="font-size:small">) != &amp;</span><span style="font-size:small">get</span><span style="font-size:small">&lt;0&gt;(</span><span style="font-size:small">x2</span><span style="font-size:small">));    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// no longer the same</span></span></span></div>
<!--TOC subsection id=sec8 Dynamically Typed Tuples-->
<h3 id="sec8" class="subsection">2.1  Dynamically Typed Tuples</h3><!--SEC END --><p>
<a id="Sec::Tuples::DynamicallyTypedTuples"></a></p><p>The class <code>any_tuple</code> represents a tuple without static type information.
All messages send between actors use this tuple type.
The type information can be either explicitly accessed for each element or the original tuple, or a subtuple of it, can be restored using <code>tuple_cast</code>.
Users of <span style="font-family:monospace">libcppa</span> usually do not need to know about
<code>any_tuple</code>, since it is used “behind the scenes”.
However, <code>any_tuple</code> can be created from a <code>cow_tuple</code>
or by using <code>make_any_tuple</code>, as shown below.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">x1</span><span style="font-size:small"> = </span><span style="font-size:small">make_cow_tuple</span><span style="font-size:small">(1, 2, 3);     </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// cow_tuple&lt;int, int, int&gt;</span></span></span><span style="font-size:small">
</span><span style="font-size:small">any_tuple</span><span style="font-size:small"> </span><span style="font-size:small">x2</span><span style="font-size:small"> = </span><span style="font-size:small">x1</span><span style="font-size:small">;                     </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// any_tuple</span></span></span><span style="font-size:small">
</span><span style="font-size:small">any_tuple</span><span style="font-size:small"> </span><span style="font-size:small">x3</span><span style="font-size:small"> = </span><span style="font-size:small">make_cow_tuple</span><span style="font-size:small">(10, 20); </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// any_tuple</span></span></span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">x4</span><span style="font-size:small"> = </span><span style="font-size:small">make_any_tuple</span><span style="font-size:small">(42);          </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// any_tuple</span></span></span></div>
<!--TOC subsection id=sec9 Casting Tuples-->
<h3 id="sec9" class="subsection">2.2  Casting Tuples</h3><!--SEC END --><p>The function <code>tuple_cast</code> restores static type information
from an <code>any_tuple</code> object.
It returns an <code>option</code> (see Section <a href="#Appendix%3A%3AOption">14.1</a>)
for a <code>cow_tuple</code> of the requested types.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">x1</span><span style="font-size:small"> = </span><span style="font-size:small">make_any_tuple</span><span style="font-size:small">(1, 2, 3);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">x2_opt</span><span style="font-size:small"> = </span><span style="font-size:small">tuple_cast</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;(</span><span style="font-size:small">x1</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">x2_opt</span><span style="font-size:small">.</span><span style="font-size:small">valid</span><span style="font-size:small">());</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">x2</span><span style="font-size:small"> = *</span><span style="font-size:small">x2_opt</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">get</span><span style="font-size:small">&lt;0&gt;(</span><span style="font-size:small">x2</span><span style="font-size:small">) == 1);</span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">get</span><span style="font-size:small">&lt;1&gt;(</span><span style="font-size:small">x2</span><span style="font-size:small">) == 2);</span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">get</span><span style="font-size:small">&lt;2&gt;(</span><span style="font-size:small">x2</span><span style="font-size:small">) == 3);</span></div><p>The function <code>tuple_cast</code> can be used with wildcards (see Section <a href="#Sec%3A%3APatternMatching%3A%3AWildcards">3.4</a>) to create a view to a subset of the original data.
No elements are copied, unless the tuple becomes detached.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">x1</span><span style="font-size:small"> = </span><span style="font-size:small">make_cow_tuple</span><span style="font-size:small">(1, 2, 3);</span><span style="font-size:small">
</span><span style="font-size:small">any_tuple</span><span style="font-size:small"> </span><span style="font-size:small">x2</span><span style="font-size:small"> = </span><span style="font-size:small">x1</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">x3_opt</span><span style="font-size:small"> = </span><span style="font-size:small">tuple_cast</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small">anything</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;(</span><span style="font-size:small">x2</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">x3_opt</span><span style="font-size:small">.</span><span style="font-size:small">valid</span><span style="font-size:small">());</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">x3</span><span style="font-size:small"> = *</span><span style="font-size:small">x3_opt</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">get</span><span style="font-size:small">&lt;0&gt;(</span><span style="font-size:small">x3</span><span style="font-size:small">) == 1);</span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">get</span><span style="font-size:small">&lt;1&gt;(</span><span style="font-size:small">x3</span><span style="font-size:small">) == 3);</span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(&amp;</span><span style="font-size:small">get</span><span style="font-size:small">&lt;0&gt;(</span><span style="font-size:small">x3</span><span style="font-size:small">) == &amp;</span><span style="font-size:small">get</span><span style="font-size:small">&lt;0&gt;(</span><span style="font-size:small">x1</span><span style="font-size:small">));</span><span style="font-size:small">
</span><span style="font-size:small">assert</span><span style="font-size:small">(&amp;</span><span style="font-size:small">get</span><span style="font-size:small">&lt;1&gt;(</span><span style="font-size:small">x3</span><span style="font-size:small">) == &amp;</span><span style="font-size:small">get</span><span style="font-size:small">&lt;2&gt;(</span><span style="font-size:small">x1</span><span style="font-size:small">));</span></div>
<!--TOC section id=sec10 Pattern Matching-->
<h2 id="sec10" class="section">3  Pattern Matching</h2><!--SEC END --><p>
<a id="Sec::PatternMatching"></a></p><p>C++ does not provide pattern matching facilities.
A general pattern matching solution for arbitrary data structures would require a language extension.
Hence, we decided to restrict our implementation to tuples, to be able to use an internal domain-specific language approach.</p>
<!--TOC subsection id=sec11 Basics-->
<h3 id="sec11" class="subsection">3.1  Basics</h3><!--SEC END --><p>
<a id="Sec::PatternMatching::Basics"></a></p><p>A match expression begins with a call to the function <code>on</code>, which returns an intermediate object providing the member function <code>when</code> and <code><span style="color:blue">operator</span></code><code>&gt;&gt;</code>.
The right-hand side of the operator denotes a callback, usually a lambda expression, that should be invoked if a tuple matches the types given to <code>on</code>,
as shown in the example below.</p><div class="lstlisting"><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> }</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small"> </span><span style="font-size:small">f</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> }</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">a</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">b</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">c</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> }</span></div><p>The result of <code><span style="color:blue">operator</span></code><code>&gt;&gt;</code> is a partial function that is defined for the types given to <code>on</code>.
A comma separated list of partial functions results in a single partial function that sequentially evaluates its subfunctions.
At most one callback is invoked, since the evaluation stops at the first match.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">fun</span><span style="font-size:small"> = (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// case1</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// is never invoked, since case1 always matches first</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div><p><span style="font-weight:bold">Note</span>: A list of partial function definitions must be enclosed in brackets if assigned to a variable.
Otherwise, the compiler assumes commas to separate variable definitions.</p><p>The function “<code>on</code>” can be used in two ways.
Either with template parameters only or with function parameters only.
The latter version deduces all types from its arguments and matches for both type and value.
The template “<code>val</code>” can be used to match only the type of a parameter.</p><div class="lstlisting"><span style="font-size:small">on</span><span style="font-size:small">(42) &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) { </span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">i</span><span style="font-size:small"> == 42); }</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"hello world"</span></span></span><span style="font-size:small">) &gt;&gt; []() { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/* ... */</span></span></span><span style="font-size:small"> }</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"print"</span></span></span><span style="font-size:small">, </span><span style="font-size:small">val</span><span style="font-size:small">&lt;</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&gt;) &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">what</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">}</span></div><p><span style="font-weight:bold">Note:</span> The given callback can have less arguments than given to the pattern.
But it is only allowed to skip arguments from left to right.</p><div class="lstlisting"><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">double</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">double</span></span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> }             </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ok</span></span></span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">double</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">double</span></span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> }      </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ok</span></span></span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">double</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">double</span></span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> } </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ok</span></span></span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">double</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> } </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// compiler error</span></span></span></div>
<!--TOC subsection id=sec12 Atoms-->
<h3 id="sec12" class="subsection">3.2  Atoms</h3><!--SEC END --><p>
<a id="Sec::PatternMatching::Atoms"></a></p><p>Assume an actor provides a mathematical service for integers.
It takes two arguments, performs a predefined operation and returns the result.
It cannot determine an operation, such as multiply or add, by receiving two operands.
Thus, the operation must be encoded into the message.
The Erlang programming language introduced an approach to use non-numerical
constants, so-called <span style="font-style:italic">atoms</span>, which have an unambiguous, special-purpose type and do not have the runtime overhead of string constants.
Atoms are mapped to integer values at compile time in <span style="font-family:monospace">libcppa</span>.
This mapping is guaranteed to be collision-free but limits atom literals to ten characters and prohibits special characters.
Legal characters are “<code>_0</code><code>-9</code><code>A</code><code>-</code><code>Za</code><code>-</code><code>z</code>” and the whitespace character.
Atoms are created using the <code><span style="color:blue">constexpr</span></code> function <code>atom</code>, as the following example illustrates.</p><div class="lstlisting"><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"add"</span></span></span><span style="font-size:small">), </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">a</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">b</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> },</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"multiply"</span></span></span><span style="font-size:small">), </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">a</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">b</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> },</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span></div><p><span style="font-weight:bold">Note</span>: The current implementation cannot enforce the restrictions at compile time, except for a length check.
Each invalid character is mapped to the whitespace character, why the assertion <code>atom</code><code>(</code><code><span style="color:#007F00"><code>"!?"</code></span></code><code>) != </code><code>atom</code><code>(</code><code><span style="color:#007F00"><code>"?!"</code></span></code><code>)</code> is not true.
However, this issue will fade away after user-defined literals become available in mainstream compilers, because it is then possible to raise a compiler error for invalid characters.</p>
<!--TOC subsection id=sec13 Reducing Redundancy with “<code>arg_match</code>” and “<code>on_arg_match</code>”-->
<h3 id="sec13" class="subsection">3.3  Reducing Redundancy with “<code>arg_match</code>” and “<code>on_arg_match</code>”</h3><!--SEC END --><p>Our previous example is quite verbose and redundant, since you have to type the types twice – as template parameter and as argument type for the lambda.
To avoid such redundancy, <code>arg_match</code> can be used as last argument to the function <code>on</code>.
This causes the compiler to deduce all further types from the signature of the given callback.</p><div class="lstlisting"><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"add"</span></span></span><span style="font-size:small">), </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">a</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">b</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> }</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// is equal to:</span></span></span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"add"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">arg_match</span><span style="font-size:small">) &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">a</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">b</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> }</span></div><p>Note that the second version does call <code>on</code> without template parameters.
Furthermore, <code>arg_match</code> must be passed as last parameter.
If all types should be deduced from the callback signature, <code>on_arg_match</code> can be used.
It is equal to <code>on</code><code>(</code><code>arg_match</code><code>)</code>.</p><div class="lstlisting"><span style="font-size:small">on_arg_match</span><span style="font-size:small"> &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">str</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/*...*/</span></span></span><span style="font-size:small"> }</span></div>
<!--TOC subsection id=sec14 Wildcards-->
<h3 id="sec14" class="subsection">3.4  Wildcards</h3><!--SEC END --><p>
<a id="Sec::PatternMatching::Wildcards"></a></p><p>The type <code>anything</code> can be used as wildcard to match any number of any types.
A pattern created by <code>on</code><code>&lt;</code><code>anything</code><code>&gt;()</code> or its alias <code>others</code><code>()</code> is useful to define a default case.
For patterns defined without template parameters, the <code><span style="color:blue">constexpr</span></code> value <code>any_vals</code> can be used as function argument.
The constant <code>any_vals</code> is of type <code>anything</code> and is nothing but syntactic sugar for defining patterns.</p><div class="lstlisting"><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small">anything</span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// tuple with int as first element</span></span></span><span style="font-size:small">
</span><span style="font-size:small">},</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">any_vals</span><span style="font-size:small">, </span><span style="font-size:small">arg_match</span><span style="font-size:small">) &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// tuple with int as last element</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// "on(any_vals, arg_match)" is equal to "on(anything{}, arg_match)"</span></span></span><span style="font-size:small">
</span><span style="font-size:small">},</span><span style="font-size:small">
</span><span style="font-size:small">others</span><span style="font-size:small">() &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// everything else (default handler)</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// "others()" is equal to "on&lt;anything&gt;()" and "on(any_vals)"</span></span></span><span style="font-size:small">
</span><span style="font-size:small">}</span></div>
<!--TOC subsection id=sec15 Guards-->
<h3 id="sec15" class="subsection">3.5  Guards</h3><!--SEC END --><p>Guards can be used to constrain a given match statement by using placeholders, as the following example illustrates.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">using</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">namespace</span></span><span style="font-size:small"> </span><span style="font-size:small">cppa</span><span style="font-size:small">::</span><span style="font-size:small">placeholders</span><span style="font-size:small">; </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// contains _x1 - _x9</span></span></span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">_x1</span><span style="font-size:small"> % 2 == 0) &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// int is even</span></span></span><span style="font-size:small">
</span><span style="font-size:small">},</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// int is odd</span></span></span><span style="font-size:small">
</span><span style="font-size:small">}</span></div><p>Guard expressions are a lazy evaluation technique.
The placeholder <code>_x1</code> is substituted with the first value of a given tuple.
All binary comparison and arithmetic operators are supported, as well as <code>&amp;&amp;</code> and <code>||</code>.
In addition, there are two functions designed to be used in guard expressions: <code>gref</code> (“guard reference”) and <code>gcall</code> (“guard function call”).
The function <code>gref</code> creates a reference wrapper.
It is similar to <code>std</code><code>::</code><code>ref</code> but it is always <code><span style="color:blue">const</span></code> and “lazy”, i.e., evaluated when a tuple arrives.
A few examples to illustrate some pitfalls:</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">val</span><span style="font-size:small"> = 42;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">_x1</span><span style="font-size:small"> == </span><span style="font-size:small">val</span><span style="font-size:small">)           </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// (1) matches if _x1 == 42</span></span></span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">_x1</span><span style="font-size:small"> == </span><span style="font-size:small">gref</span><span style="font-size:small">(</span><span style="font-size:small">val</span><span style="font-size:small">))     </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// (2) matches if _x1 == val</span></span></span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">_x1</span><span style="font-size:small"> == </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">ref</span><span style="font-size:small">(</span><span style="font-size:small">val</span><span style="font-size:small">)) </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// (3) ok, because of placeholder</span></span></span><span style="font-size:small">
</span><span style="font-size:small">others</span><span style="font-size:small">().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">gref</span><span style="font-size:small">(</span><span style="font-size:small">val</span><span style="font-size:small">) == 42)       </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// (4) matches everything</span></span></span><span style="font-size:small">
</span><span style="font-size:small">                                     </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">//     as long as val == 42</span></span></span><span style="font-size:small">
</span><span style="font-size:small">others</span><span style="font-size:small">().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">ref</span><span style="font-size:small">(</span><span style="font-size:small">val</span><span style="font-size:small">) == 42)   </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// (5) compiler error</span></span></span></div><p>Statement <span style="font-family:monospace">(5)</span> is evaluated immediately and returns a boolean, whereas statement <span style="font-family:monospace">(4)</span> creates a valid guard expression.
Thus, you should always use <code>gref</code> instead of <code>std</code><code>::</code><code>ref</code> to avoid errors.</p><p>The second function, <code>gcall</code>, encapsulates a function call.
Its usage is similar to <code>std</code><code>::</code><code>bind</code>, but there is also a short version for unary functions: <code>gcall</code><code>(</code><code>fun</code><code>, </code><code>_x1</code><code>)</code> is equal to <code>_x1</code><code>(</code><code>fun</code><code>)</code>.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">vec_sorted</span><span style="font-size:small"> = [](</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">vector</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt; </span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small">&amp; </span><span style="font-size:small">vec</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">return</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">is_sorted</span><span style="font-size:small">(</span><span style="font-size:small">vec</span><span style="font-size:small">.</span><span style="font-size:small">begin</span><span style="font-size:small">(), </span><span style="font-size:small">vec</span><span style="font-size:small">.</span><span style="font-size:small">end</span><span style="font-size:small">());</span><span style="font-size:small">
</span><span style="font-size:small">};</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">vector</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;&gt;().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">gcall</span><span style="font-size:small">(</span><span style="font-size:small">vec_sorted</span><span style="font-size:small">, </span><span style="font-size:small">_x1</span><span style="font-size:small">)) </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// is equal to:</span></span></span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">vector</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;&gt;().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">_x1</span><span style="font-size:small">(</span><span style="font-size:small">vec_sorted</span><span style="font-size:small">)))</span></div>
<!--TOC subsubsection id=sec16 Placeholder Interface-->
<h4 id="sec16" class="subsubsection">3.5.1  Placeholder Interface</h4><!--SEC END --><div class="lstlisting"><span style="font-size:small"><span style="color:blue">template</span></span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">X</span><span style="font-size:small">&gt;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">struct</span></span><span style="font-size:small"> </span><span style="font-size:small">guard_placeholder</span><span style="font-size:small">;</span></div><table style="border-spacing:6px;border-collapse:separate;width:100%" class="cellpading0"><tr><td style="vertical-align:middle;text-align:left;"  colspan=2><span style="font-size:large"><span style="font-weight:bold">Member functions</span></span><span style="font-size:large"> </span><span style="font-size:small">(</span><code><span style="font-size:small">x</span></code><span style="font-size:small"> represents the value at runtime, </span><code><span style="font-size:small">y</span></code><span style="font-size:small"> represents an iterable container)</span> </td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" > <code>size</code><code>()</code></td><td style="vertical-align:middle;text-align:left;" >Returns <code>x</code><code>.</code><code>size</code><code>()</code> </td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" > <code>empty</code><code>()</code></td><td style="vertical-align:middle;text-align:left;" >Returns <code>x</code><code>.</code><code>empty</code><code>()</code> </td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" > <code>not_empty</code><code>()</code></td><td style="vertical-align:middle;text-align:left;" >Returns <code>!</code><code>x</code><code>.</code><code>empty</code><code>()</code> </td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" > <code>front</code><code>()</code></td><td style="vertical-align:middle;text-align:left;" >Returns an <code>option</code> (see Section <a href="#Appendix%3A%3AOption">14.1</a>) to <code>x</code><code>.</code><code>front</code><code>()</code> </td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" > <code>in</code><code>(</code><code>y</code><code>)</code></td><td style="vertical-align:middle;text-align:left;" >Returns <code><span style="color:blue">true</span></code> if <code>y</code> contains <code>x</code>, <code><span style="color:blue">false</span></code> otherwise</td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" > <code>not_in</code><code>(</code><code>y</code><code>)</code></td><td style="vertical-align:middle;text-align:left;" >Returns <code>!</code><code>in</code><code>(</code><code>y</code><code>)</code> </td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" >&nbsp;</td></tr>
</table>
<!--TOC subsubsection id=sec17 Examples for Guard Expressions-->
<h4 id="sec17" class="subsubsection">3.5.2  Examples for Guard Expressions</h4><!--SEC END --><div class="lstlisting"><span style="font-size:small"><span style="color:blue">using</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">namespace</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">typedef</span></span><span style="font-size:small"> </span><span style="font-size:small">vector</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt; </span><span style="font-size:small">ivec</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">vector</span><span style="font-size:small">&lt;</span><span style="font-size:small">string</span><span style="font-size:small">&gt; </span><span style="font-size:small">strings</span><span style="font-size:small">{</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"abc"</span></span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"def"</span></span></span><span style="font-size:small">};</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small">ivec</span><span style="font-size:small">&gt;().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">_x1</span><span style="font-size:small">.</span><span style="font-size:small">front</span><span style="font-size:small">() == 0) &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">ivec</span><span style="font-size:small">&amp; </span><span style="font-size:small">v</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// note: we don't have to check whether _x1 is empty in our guard,</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">//       because '_x1.front()' returns an option for a </span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">//       reference to the first element</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">v</span><span style="font-size:small">.</span><span style="font-size:small">size</span><span style="font-size:small">() &gt;= 1);</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">v</span><span style="font-size:small">.</span><span style="font-size:small">front</span><span style="font-size:small">() == 0);</span><span style="font-size:small">
</span><span style="font-size:small">},</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">_x1</span><span style="font-size:small">.</span><span style="font-size:small">in</span><span style="font-size:small">({10, 20, 30})) &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">i</span><span style="font-size:small"> == 10 || </span><span style="font-size:small">i</span><span style="font-size:small"> == 20 || </span><span style="font-size:small">i</span><span style="font-size:small"> == 30);</span><span style="font-size:small">
</span><span style="font-size:small">},</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small">string</span><span style="font-size:small">&gt;().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">_x1</span><span style="font-size:small">.</span><span style="font-size:small">not_in</span><span style="font-size:small">(</span><span style="font-size:small">strings</span><span style="font-size:small">)) &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">str</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">assert</span><span style="font-size:small">(</span><span style="font-size:small">str</span><span style="font-size:small"> != </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"abc"</span></span></span><span style="font-size:small"> &amp;&amp; </span><span style="font-size:small">str</span><span style="font-size:small"> != </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"def"</span></span></span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">},</span><span style="font-size:small">
</span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small">string</span><span style="font-size:small">&gt;().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">_x1</span><span style="font-size:small">.</span><span style="font-size:small">size</span><span style="font-size:small">() == 10) &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">str</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">}</span></div>
<!--TOC subsection id=sec18 Projections and Extractors-->
<h3 id="sec18" class="subsection">3.6  Projections and Extractors</h3><!--SEC END --><p>Projections perform type conversions or extract data from a given input.
If a callback expects an integer but the received message contains a string, a projection can be used to perform a type conversion on-the-fly.
This conversion should be free of side-effects and, in particular, shall not throw exceptions, because a failed projection is not an error.
A pattern simply does not match if a projection failed.
Let us have a look at a simple example.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">intproj</span><span style="font-size:small"> = [](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">str</span><span style="font-size:small">) -&gt; </span><span style="font-size:small">option</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt; {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">char</span></span><span style="font-size:small">* </span><span style="font-size:small">endptr</span><span style="font-size:small"> = </span><span style="font-size:small"><span style="color:blue">nullptr</span></span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">result</span><span style="font-size:small"> = </span><span style="font-size:small"><span style="color:blue">static_cast</span></span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;(</span><span style="font-size:small">strtol</span><span style="font-size:small">(</span><span style="font-size:small">str</span><span style="font-size:small">.</span><span style="font-size:small">c_str</span><span style="font-size:small">(), &amp;</span><span style="font-size:small">endptr</span><span style="font-size:small">, 10));</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">if</span></span><span style="font-size:small"> (</span><span style="font-size:small">endptr</span><span style="font-size:small"> != </span><span style="font-size:small"><span style="color:blue">nullptr</span></span><span style="font-size:small"> &amp;&amp; *</span><span style="font-size:small">endptr</span><span style="font-size:small"> == </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">'\0'</span></span></span><span style="font-size:small">) </span><span style="font-size:small"><span style="color:blue">return</span></span><span style="font-size:small"> </span><span style="font-size:small">result</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">return</span></span><span style="font-size:small"> {};</span><span style="font-size:small">
</span><span style="font-size:small">};</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">fun</span><span style="font-size:small"> = (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">intproj</span><span style="font-size:small">) &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// case 1, successfully converted a string</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on_arg_match</span><span style="font-size:small"> &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">str</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// case 2, str is not an integer</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div><p>The lambda <code>intproj</code> is a <code>string</code> ⇒ <code><span style="color:blue">int</span></code> projection, but note that it does not return an integer.
It returns <code>option</code><code>&lt;</code><code><span style="color:blue">int</span></code><code>&gt;</code>, because the projection is not guaranteed to always succeed.
An empty <code>option</code> indicates, that a value does not have a valid mapping to an integer.
A pattern does not match if a projection failed.</p><p><span style="font-weight:bold">Note</span>: Functors used as projection must take exactly one argument and must return a value.
The types for the pattern are deduced from the functor’s signature.
If the functor returns an <code>option</code><code>&lt;</code><code>T</code><code>&gt;</code>, then <code>T</code> is deduced.</p>
<!--TOC section id=sec19 Actors-->
<h2 id="sec19" class="section">4  Actors</h2><!--SEC END --><p><span style="font-family:monospace">libcppa</span> provides three actor implementations, each covering a particular use case.
The class <code>local_actor</code> is the base class for all implementations, except for (remote) proxy actors.</p>
<!--TOC subsection id=sec20 Local Actors-->
<h3 id="sec20" class="subsection">4.1  Local Actors</h3><!--SEC END --><p>The class <code>local_actor</code> describes a local running actor.
It provides a common interface for actor operations like trapping exit messages or finishing execution.</p>
<!--TOC subsubsection id=sec21 “Keyword” <span style="font-family:monospace">self</span>-->
<h4 id="sec21" class="subsubsection">4.1.1  “Keyword” <span style="font-family:monospace">self</span></h4><!--SEC END --><p>The <code>self</code> pointer is an essential ingredient of our design.
It identifies the running actor similar to the implicit <code><span style="color:blue">this</span></code> pointer identifying an object within a member function.
Unlike <code><span style="color:blue">this</span></code>, though, <code>self</code> is not limited to a particular scope.
The <code>self</code> pointer is used implicitly, whenever an actor calls functions like <code>send</code> or <code>receive</code>, but can be accessed to use more advanced actor operations such as linking to another actor, e.g., by calling <code>self</code><code>-&gt;</code><code>link_to</code><code>(</code><code>other</code><code>)</code>.
The <code>self</code> pointer is convertible to <code>actor_ptr</code> and <code>local_actor</code><code>*</code>, but it is neither copyable nor assignable.
Thus, <code><span style="color:blue">auto</span></code><code> </code><code>s</code><code> = </code><code>self</code> will cause a compiler error, while <code>actor_ptr</code><code> </code><code>s</code><code> = </code><code>self</code> works as expected.</p><p>A thread that accesses <code>self</code> is converted on-the-fly to an actor if needed.
Hence, “everything is an actor” in <span style="font-family:monospace">libcppa</span>.</p>
<!--TOC subsubsection id=sec22 Interface-->
<h4 id="sec22" class="subsubsection">4.1.2  Interface</h4><!--SEC END --><div class="lstlisting"><span style="font-size:small"><span style="color:blue">class</span></span><span style="font-size:small"> </span><span style="font-size:small">local_actor</span><span style="font-size:small">;</span></div><table style="border-spacing:6px;border-collapse:separate;width:100%" class="cellpading0"><tr><td style="vertical-align:middle;text-align:left;"  colspan=2><span style="font-size:large"><span style="font-weight:bold">Member functions</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small">quit</span></code><code><span style="font-size:small">(</span></code><code><span style="font-size:small">uint32_t</span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">reason</span></code><code><span style="font-size:small"> = </span></code><code><span style="font-size:small">normal</span></code><code><span style="font-size:small">)</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Finishes execution of this actor </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap"  colspan=2><span style="font-size:small"><span style="font-weight:bold">Observers</span></span><span style="font-size:small"> </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small"><span style="color:blue">bool</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">trap_exit</span></code><code><span style="font-size:small">()</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Checks whether this actor traps exit messages </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small"><span style="color:blue">bool</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">chaining</span></code><code><span style="font-size:small">()</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Checks whether this actor uses the “chained send” optimization (see Section </span><a href="#Sec%3A%3ASend%3A%3AChainedSend"><span style="font-size:small">5.2</span></a><span style="font-size:small">) </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small">any_tuple</span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">last_dequeued</span></code><code><span style="font-size:small">()</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Returns the last message that was dequeued from the actor’s mailbox<br>
</span><span style="font-size:small"><span style="font-weight:bold">Note</span></span><span style="font-size:small">: Only set during callback invocation </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small">actor_ptr</span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">last_sender</span></code><code><span style="font-size:small">()</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Returns the sender of the last dequeued message<br>
</span><span style="font-size:small"><span style="font-weight:bold">Note</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">: Only set during callback invocation<br>
</span><span style="font-size:small"><span style="font-weight:bold">Note</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">: Used by the function </span><code><span style="font-size:small">reply</span></code><span style="font-size:small"> (see Section </span><a href="#Sec%3A%3ASend%3A%3AReply"><span style="font-size:small">5.1</span></a><span style="font-size:small">) </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap"  colspan=2><span style="font-size:small"><span style="font-weight:bold">Modifiers</span></span><span style="font-size:small"> </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small"><span style="color:blue">void</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">trap_exit</span></code><code><span style="font-size:small">(</span></code><code><span style="font-size:small"><span style="color:blue">bool</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">enabled</span></code><code><span style="font-size:small">)</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Enables or disables trapping of exit messages </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small"><span style="color:blue">void</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">chaining</span></code><code><span style="font-size:small">(</span></code><code><span style="font-size:small"><span style="color:blue">bool</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">enabled</span></code><code><span style="font-size:small">)</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Enables or disables chained send </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
</table>
<!--TOC subsection id=sec23 Types of Actors-->
<h3 id="sec23" class="subsection">4.2  Types of Actors</h3><!--SEC END --><p>We have already shown the differences of context-switching and event-based actors in Section <a href="#Sec%3A%3AReceive">6</a>.
Context-switching and event-based actors are scheduled cooperatively in a thread pool.
Developers can opt-out of this cooperative scheduling by using thread-mapped actors.</p>
<!--TOC subsubsection id=sec24 Thread-Mapped Actors-->
<h4 id="sec24" class="subsubsection">4.2.1  Thread-Mapped Actors</h4><!--SEC END --><p>This is the implicit type of all threads that were converted to actors implicitly.
Furthermore, this type is used for actors created with <code>spawn</code><code>&lt;</code><code>detached</code><code>&gt;</code>.
It is recommended to use detached actors whenever an actor could starve other actors, e.g., by calling time-expensive, blocking system calls.
Detached actors also could be used for actors that need to stay responsive, independent of the current work load.
However, threads do not scale well.
Hence, detached actors should be used only in small numbers for long-lived actors.</p>
<!--TOC subsubsection id=sec25 Context-Switching Actors-->
<h4 id="sec25" class="subsubsection">4.2.2  Context-Switching Actors</h4><!--SEC END --><p>Context-switching actors have an own control flow and allow developers to spawn arbitrary functions as actors.
The downside of context-switching actors is that each actor needs to allocate its own stack.
This seriously impacts the performance for short-lived actors and is not applicable for large-scale actor systems.
This implementations allows for an easy migration of previously threaded application, but a system should not contain more than a few hundred context-switching actors.</p>
<!--TOC subsubsection id=sec26 Event-Based Actors-->
<h4 id="sec26" class="subsubsection">4.2.3  Event-Based Actors</h4><!--SEC END --><p>This is the recommended implementation for most use cases.
Event-based actors have a small memory footprint and are thus very lightweight.
The behavior-based API makes it harder to nest receives, but this implementation clearly scales best.
See Section <a href="#Sec%3A%3AReceive%3A%3AEventBased">6.2</a> for a few examples.

</p>
<!--TOC section id=sec27 Sending Messages-->
<h2 id="sec27" class="section">5  Sending Messages</h2><!--SEC END --><p>
<a id="Sec::Send"></a></p><p>Messages can be sent by using either the function <code>send</code>, or <code>send_tuple</code>, or <code><span style="color:blue">operator</span></code><code>&lt;&lt;</code>. The variadic template function <code>send</code> has the following signature.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">template</span></span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">typename</span></span><span style="font-size:small">... </span><span style="font-size:small">Args</span><span style="font-size:small">&gt;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">void</span></span><span style="font-size:small"> </span><span style="font-size:small">send</span><span style="font-size:small">(</span><span style="font-size:small">actor_ptr</span><span style="font-size:small"> </span><span style="font-size:small">whom</span><span style="font-size:small">, </span><span style="font-size:small">Args</span><span style="font-size:small">&amp;&amp;... </span><span style="font-size:small">what</span><span style="font-size:small">);</span></div><p>The variadic template pack <code>what</code><code>...</code> is converted to a dynamically typed tuple (see Section <a href="#Sec%3A%3ATuples%3A%3ADynamicallyTypedTuples">2.1</a>) and then enqueued to the mailbox of <code>whom</code>.
The following example shows two equal sends, one using <code>send</code> and the other using <code><span style="color:blue">operator</span></code><code>&lt;&lt;</code>.</p><div class="lstlisting"><span style="font-size:small">actor_ptr</span><span style="font-size:small"> </span><span style="font-size:small">other</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">(...);</span><span style="font-size:small">
</span><span style="font-size:small">send</span><span style="font-size:small">(</span><span style="font-size:small">other</span><span style="font-size:small">, 1, 2, 3);</span><span style="font-size:small">
</span><span style="font-size:small">other</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">make_any_tuple</span><span style="font-size:small">(1, 2, 3);</span></div><p>Using the function <code>send</code> is more compact, but does not have any other benefit.
However, note that you should not use <code>send</code> if you already have an instance of <code>any_tuple</code>, because it creates a new tuple containing the old one.</p><div class="lstlisting"><span style="font-size:small">actor_ptr</span><span style="font-size:small"> </span><span style="font-size:small">other</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">(...);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">msg</span><span style="font-size:small"> = </span><span style="font-size:small">make_any_tuple</span><span style="font-size:small">(1, 2, 3);</span><span style="font-size:small">
</span><span style="font-size:small">send</span><span style="font-size:small">(</span><span style="font-size:small">other</span><span style="font-size:small">, </span><span style="font-size:small">msg</span><span style="font-size:small">); </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// oops, creates a new tuple that contains msg</span></span></span><span style="font-size:small">
</span><span style="font-size:small">other</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">msg</span><span style="font-size:small">; </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ok</span></span></span></div><p>The function <code>send_tuple</code> is equal to <code><span style="color:blue">operator</span></code><code>&lt;&lt;</code>.
Choosing one or the other is merely a matter of personal preferences.</p>
<!--TOC subsection id=sec28 Replying to Messages-->
<h3 id="sec28" class="subsection">5.1  Replying to Messages</h3><!--SEC END --><p>
<a id="Sec::Send::Reply"></a></p><p>During callback invokation, <code>self</code><code>-&gt;</code><code>last_sender</code><code>()</code> is set.
This identifies the sender of the received message and is used implicitly by the functions <code>reply</code> and <code>reply_tuple</code>.</p><p>Note that <code>reply</code><code>(...)</code> is <span style="font-weight:bold">not</span> equal to <code>send</code><code>(</code><code>self</code><code>-&gt;</code><code>last_sender</code><code>(), ...)</code>.
The function <code>send</code> always uses asynchronous message passing, whereas <code>reply</code> will send a synchronous response message if the received message was a synchronous request
(see Section <a href="#Sec%3A%3ASync">7</a>).</p>
<!--TOC subsection id=sec29 Chaining Sends-->
<h3 id="sec29" class="subsection">5.2  Chaining Sends</h3><!--SEC END --><p>
<a id="Sec::Send::ChainedSend"></a></p><p>Sending a message to a cooperatively scheduled actor usually causes the receiving actor to be put into the scheduler’s job queue if it is currently blocked, i.e., is waiting for a new message.
This job queue is accessed by worker threads.
The <span style="font-style:italic">chaining</span> optimization does not cause the receiver to be put into the scheduler’s job queue if it is currently blocked.
The receiver is stored as successor of the currently running actor instead.
Hence, the active worker thread does not need to access the job queue, which significantly speeds up execution.
However, this optimization can be inefficient if an actor first sends a message and then starts computation.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">void</span></span><span style="font-size:small"> </span><span style="font-size:small">foo</span><span style="font-size:small">(</span><span style="font-size:small">actor_ptr</span><span style="font-size:small"> </span><span style="font-size:small">other</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">send</span><span style="font-size:small">(</span><span style="font-size:small">other</span><span style="font-size:small">, ...);</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">very_long_computation</span><span style="font-size:small">();</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">}</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">main</span><span style="font-size:small">() {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">(...);</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">b</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">(</span><span style="font-size:small">foo</span><span style="font-size:small">, </span><span style="font-size:small">a</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">}</span></div><p>The example above illustrates an inefficient work flow.
The actor <code>other</code> is marked as successor of the <code>foo</code> actor but its execution is delayed until <code>very_long_computation</code><code>()</code> is done.
In general, actors should follow the work flow <code>receive</code> ⇒<code>compute</code> ⇒ <code>send</code><code> </code><code>results</code>.
However, this optimization can be disabled by calling <code>self</code><code>-&gt;</code><code>chaining</code><code>(</code><code><span style="color:blue">false</span></code><code>)</code> if an actor does not match this work flow.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">void</span></span><span style="font-size:small"> </span><span style="font-size:small">foo</span><span style="font-size:small">(</span><span style="font-size:small">actor_ptr</span><span style="font-size:small"> </span><span style="font-size:small">other</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">self</span><span style="font-size:small">-&gt;</span><span style="font-size:small">chaining</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:blue">false</span></span><span style="font-size:small">);   </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// disable chaining optimization</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">send</span><span style="font-size:small">(</span><span style="font-size:small">other</span><span style="font-size:small">, ...);        </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// not delayed by very_long_compuation</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">very_long_computation</span><span style="font-size:small">();</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">}</span></div>
<!--TOC subsection id=sec30 Delaying Messages-->
<h3 id="sec30" class="subsection">5.3  Delaying Messages</h3><!--SEC END --><p>Messages can be delayed, e.g., to implement time-based polling strategies, by using one of the functions <code>delayed_send</code>, <code>delayed_send_tuple</code>, <code>delayed_reply</code>, or <code>delayed_reply_tuple</code>.
The following example illustrates a polling strategy using <code>delayed_send</code>.</p><div class="lstlisting"><span style="font-size:small">delayed_send</span><span style="font-size:small">(</span><span style="font-size:small">self</span><span style="font-size:small">, </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">chrono</span><span style="font-size:small">::</span><span style="font-size:small">seconds</span><span style="font-size:small">(1), </span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"poll"</span></span></span><span style="font-size:small">));</span><span style="font-size:small">
</span><span style="font-size:small">receive_loop</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"poll"</span></span></span><span style="font-size:small">)) &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// poll a resource...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// schedule next polling</span></span></span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">delayed_send</span><span style="font-size:small">(</span><span style="font-size:small">self</span><span style="font-size:small">, </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">chrono</span><span style="font-size:small">::</span><span style="font-size:small">seconds</span><span style="font-size:small">(1), </span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"poll"</span></span></span><span style="font-size:small">));</span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div>
<!--TOC subsection id=sec31 Forwarding Messages-->
<h3 id="sec31" class="subsection">5.4  Forwarding Messages</h3><!--SEC END --><p>The function <code>forward_to</code> forwards the last dequeued message to an other actor.
Forwarding a synchronous message will also transfer responsibility for the request, i.e., the receiver of the forwarded message can reply as usual and the original sender of the message will receive the response.
The following diagram illustrates forwarding of a synchronous message from actor <span style="font-family:monospace">B</span> to actor <span style="font-family:monospace">C</span>.</p><pre class="verbatim">            A                  B                  C
            |                  |                  |
            | --(sync_send)--&gt; |                  |
            |                  | --(forward_to)-&gt; |
            |                  X                  |---\
            |                                     |   | compute
            |                                     |   | result
            |                                     |&lt;--/
            | &lt;-------------(reply)-------------- |
            |                                     X
            |---\
            |   | handle
            |   | response
            |&lt;--/
            |
            X
</pre><p>The forwarding is completely transparent to actor <span style="font-family:monospace">C</span>, since it will see actor <span style="font-family:monospace">A</span> as sender of the message.
However, actor <span style="font-family:monospace">A</span> will see actor <span style="font-family:monospace">C</span> as sender of the response message instead of actor <span style="font-family:monospace">B</span> and thus could recognize the forwarding by evaluating <code>self</code><code>-&gt;</code><code>last_sender</code><code>()</code>.
</p>
<!--TOC section id=sec32 Receiving Messages-->
<h2 id="sec32" class="section">6  Receiving Messages</h2><!--SEC END --><p>
<a id="Sec::Receive"></a></p><p>Event-based actors differ in receiving messages from context-switching and thread-mapped actors: the former define their behavior as a message handler that is invoked whenever a new messages arrives in the actor’s mailbox, whereas the latter use an explicit receive function.
The current <span style="font-style:italic">behavior</span> of an actor is its response to the <span style="font-style:italic">next</span> incoming message and includes (a) sending messages to other actors, (b) creation of more actors, and (c) setting a new behavior.</p>
<!--TOC subsection id=sec33 Blocking API for Context-Switching and Thread-Mapped Actors-->
<h3 id="sec33" class="subsection">6.1  Blocking API for Context-Switching and Thread-Mapped Actors</h3><!--SEC END --><p>
<a id="Sec::Receive::Function"></a></p><p>The function <code>receive</code> sequentially iterates over all elements in the mailbox beginning with the first.
It takes a partial function that is applied to the elements in the mailbox until an element was matched by the partial function.
An actor calling <code>receive</code> is blocked until it successfully dequeued a message from its mailbox or an optional timeout occurs.</p><div class="lstlisting"><span style="font-size:small">receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;().</span><span style="font-size:small">when</span><span style="font-size:small">(</span><span style="font-size:small">_x1</span><span style="font-size:small"> &gt; 0) &gt;&gt; </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">);</span></div><p>The code snippet above illustrates the use of <code>receive</code>.
Note that the partial function passed to <code>receive</code> is a temporary object at runtime.
Hence, using receive inside a loop would cause creation of a new partial function on each iteration.
<span style="font-family:monospace">libcppa</span> provides three predefined receive loops to provide a more efficient but yet convenient way of defining receive loops.</p><table border=1  style="border-spacing:0;width:100%" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" ><code><span style="color:#7F007F"><code>// DON'T</code></span></code></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><code><span style="color:#7F007F"><code>// DO</code></span></code> </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="lstlisting"><span style="font-size:small"><span style="color:blue">for</span></span><span style="font-size:small"> (;;) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  );</span><span style="font-size:small">
</span><span style="font-size:small">}</span></div></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="lstlisting"><span style="font-size:small">receive_loop</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">);</span></div></td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="lstlisting"><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">vector</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt; </span><span style="font-size:small">results</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">for</span></span><span style="font-size:small"> (</span><span style="font-size:small"><span style="color:blue">size_t</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small"> = 0; </span><span style="font-size:small">i</span><span style="font-size:small"> &lt; 10; ++</span><span style="font-size:small">i</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [&amp;](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">value</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">      </span><span style="font-size:small">results</span><span style="font-size:small">.</span><span style="font-size:small">push_back</span><span style="font-size:small">(</span><span style="font-size:small">value</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">    }</span><span style="font-size:small">
</span><span style="font-size:small">  );</span><span style="font-size:small">
</span><span style="font-size:small">}</span></div></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="lstlisting"><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">vector</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt; </span><span style="font-size:small">results</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">size_t</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small"> = 0;</span><span style="font-size:small">
</span><span style="font-size:small">receive_for</span><span style="font-size:small">(</span><span style="font-size:small">i</span><span style="font-size:small">, 10) (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [&amp;](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">value</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">results</span><span style="font-size:small">.</span><span style="font-size:small">push_back</span><span style="font-size:small">(</span><span style="font-size:small">value</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div></td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="lstlisting"><span style="font-size:small"><span style="color:blue">size_t</span></span><span style="font-size:small"> </span><span style="font-size:small">received</span><span style="font-size:small"> = 0;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">do</span></span><span style="font-size:small"> {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">others</span><span style="font-size:small">() &gt;&gt; [&amp;]() {</span><span style="font-size:small">
</span><span style="font-size:small">      ++</span><span style="font-size:small">received</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">    }</span><span style="font-size:small">
</span><span style="font-size:small">  );</span><span style="font-size:small">
</span><span style="font-size:small">} </span><span style="font-size:small"><span style="color:blue">while</span></span><span style="font-size:small"> (</span><span style="font-size:small">received</span><span style="font-size:small"> &lt; 10);</span></div></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="lstlisting"><span style="font-size:small"><span style="color:blue">size_t</span></span><span style="font-size:small"> </span><span style="font-size:small">received</span><span style="font-size:small"> = 0;</span><span style="font-size:small">
</span><span style="font-size:small">do_receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">others</span><span style="font-size:small">() &gt;&gt; [&amp;]() {</span><span style="font-size:small">
</span><span style="font-size:small">    ++</span><span style="font-size:small">received</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">).</span><span style="font-size:small">until</span><span style="font-size:small">(</span><span style="font-size:small">gref</span><span style="font-size:small">(</span><span style="font-size:small">received</span><span style="font-size:small">) &gt;= 10);</span></div></td></tr>
</table><p>The examples above illustrate the correct usage of the three loops <code>receive_loop</code>, <code>receive_for</code> and <code>do_receive</code><code>(...).</code><code>until</code>.
It is possible to nest receives and receive loops.</p><div class="lstlisting"><span style="font-size:small">receive_loop</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">value1</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">      </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small">&gt;() &gt;&gt; [&amp;](</span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small"> </span><span style="font-size:small">value2</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">cout</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">value1</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">" =&gt; "</span></span></span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">value2</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">endl</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">      }</span><span style="font-size:small">
</span><span style="font-size:small">    );</span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div>
<!--TOC subsection id=sec34 Event-Based API-->
<h3 id="sec34" class="subsection">6.2  Event-Based API</h3><!--SEC END --><p>
<a id="Sec::Receive::EventBased"></a></p><p>An event-based actor uses <code>become</code> to set its behavior.
The given behavior is then executed until it is replaced by another call to <code>become</code> or the actor finishes execution.
A subtype of <code>event_based_actor</code> must implement the pure virtual member function <code>init</code>.
An implementation of <code>init</code> shall set an initial behavior by using <code>become</code>.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">class</span></span><span style="font-size:small"> </span><span style="font-size:small">printer</span><span style="font-size:small"> : </span><span style="font-size:small"><span style="color:blue">public</span></span><span style="font-size:small"> </span><span style="font-size:small">event_based_actor</span><span style="font-size:small"> {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">void</span></span><span style="font-size:small"> </span><span style="font-size:small">init</span><span style="font-size:small">() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">become</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">      </span><span style="font-size:small">others</span><span style="font-size:small">() &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">cout</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">to_string</span><span style="font-size:small">(</span><span style="font-size:small">self</span><span style="font-size:small">-&gt;</span><span style="font-size:small">last_received</span><span style="font-size:small">()) &lt;&lt; </span><span style="font-size:small">endl</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">      }</span><span style="font-size:small">
</span><span style="font-size:small">    );</span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">};</span></div>
<!--TOC subsubsection id=sec35 State-Based Actors-->
<h4 id="sec35" class="subsubsection">6.2.1  State-Based Actors</h4><!--SEC END --><p>Another way to implement event-based actors is provided by the class <code>sb_actor</code> (“State-Based Actor”).
This base class calls <code>become</code><code>(</code><code>init_state</code><code>)</code> in its <code>init</code> member function.
Hence, a subclass must only provide a member of type <code>behavior</code> named <code>init_state</code>.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">struct</span></span><span style="font-size:small"> </span><span style="font-size:small">printer</span><span style="font-size:small"> : </span><span style="font-size:small">sb_actor</span><span style="font-size:small">&lt;</span><span style="font-size:small">printer</span><span style="font-size:small">&gt; {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">behavior</span><span style="font-size:small"> </span><span style="font-size:small">init_state</span><span style="font-size:small"> = (</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">others</span><span style="font-size:small">() &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">      </span><span style="font-size:small">cout</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">to_string</span><span style="font-size:small">(</span><span style="font-size:small">self</span><span style="font-size:small">-&gt;</span><span style="font-size:small">last_received</span><span style="font-size:small">()) &lt;&lt; </span><span style="font-size:small">endl</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">    }</span><span style="font-size:small">
</span><span style="font-size:small">  );</span><span style="font-size:small">
</span><span style="font-size:small">};</span></div><p>Note that <code>sb_actor</code> uses the Curiously Recurring Template Pattern. Thus, the derived class must be given as template parameter.
This technique allows <code>sb_actor</code> to access the <code>init_state</code> member of a derived class.</p><p>The following example illustrates a more advanced state-based actor that implements a stack with a fixed maximum number of elements.
Note that this example uses non-static member initialization and thus might not compile with some compilers.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">class</span></span><span style="font-size:small"> </span><span style="font-size:small">fixed_stack</span><span style="font-size:small"> : </span><span style="font-size:small"><span style="color:blue">public</span></span><span style="font-size:small"> </span><span style="font-size:small">sb_actor</span><span style="font-size:small">&lt;</span><span style="font-size:small">fixed_stack</span><span style="font-size:small">&gt; {</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// grant access to the private init_state member</span></span></span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:blue">friend</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">class</span></span><span style="font-size:small"> </span><span style="font-size:small">sb_actor</span><span style="font-size:small">&lt;</span><span style="font-size:small">fixed_stack</span><span style="font-size:small">&gt;;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:blue">static</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">constexpr</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">size_t</span></span><span style="font-size:small"> </span><span style="font-size:small">max_size</span><span style="font-size:small"> = 10;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">vector</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt; </span><span style="font-size:small">data</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">behavior</span><span style="font-size:small"> </span><span style="font-size:small">empty</span><span style="font-size:small"> = (</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"push"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">arg_match</span><span style="font-size:small">) &gt;&gt; [=](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">what</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">data</span><span style="font-size:small">.</span><span style="font-size:small">push_back</span><span style="font-size:small">(</span><span style="font-size:small">what</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">become</span><span style="font-size:small">(</span><span style="font-size:small">filled</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">        },</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"pop"</span></span></span><span style="font-size:small">)) &gt;&gt; [=]() {</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">reply</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"failure"</span></span></span><span style="font-size:small">));</span><span style="font-size:small">
</span><span style="font-size:small">        }</span><span style="font-size:small">
</span><span style="font-size:small">    );</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">behavior</span><span style="font-size:small"> </span><span style="font-size:small">filled</span><span style="font-size:small"> = (</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"push"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">arg_match</span><span style="font-size:small">) &gt;&gt; [=](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">what</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">data</span><span style="font-size:small">.</span><span style="font-size:small">push_back</span><span style="font-size:small">(</span><span style="font-size:small">what</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small"><span style="color:blue">if</span></span><span style="font-size:small"> (</span><span style="font-size:small">data</span><span style="font-size:small">.</span><span style="font-size:small">size</span><span style="font-size:small">() == </span><span style="font-size:small">max_size</span><span style="font-size:small">)</span><span style="font-size:small">
</span><span style="font-size:small">                </span><span style="font-size:small">become</span><span style="font-size:small">(</span><span style="font-size:small">full</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">        },</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"pop"</span></span></span><span style="font-size:small">)) &gt;&gt; [=]() {</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">reply</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"ok"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">data</span><span style="font-size:small">.</span><span style="font-size:small">back</span><span style="font-size:small">());</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">data</span><span style="font-size:small">.</span><span style="font-size:small">pop_back</span><span style="font-size:small">();</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small"><span style="color:blue">if</span></span><span style="font-size:small"> (</span><span style="font-size:small">data</span><span style="font-size:small">.</span><span style="font-size:small">empty</span><span style="font-size:small">())</span><span style="font-size:small">
</span><span style="font-size:small">                </span><span style="font-size:small">become</span><span style="font-size:small">(</span><span style="font-size:small">empty</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">        }</span><span style="font-size:small">
</span><span style="font-size:small">    );</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">behavior</span><span style="font-size:small"> </span><span style="font-size:small">full</span><span style="font-size:small"> = (</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"push"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">arg_match</span><span style="font-size:small">) &gt;&gt; [=](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">) { },</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"pop"</span></span></span><span style="font-size:small">)) &gt;&gt; [=]() {</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">reply</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"ok"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">data</span><span style="font-size:small">.</span><span style="font-size:small">back</span><span style="font-size:small">());</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">data</span><span style="font-size:small">.</span><span style="font-size:small">pop_back</span><span style="font-size:small">();</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">become</span><span style="font-size:small">(</span><span style="font-size:small">filled</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">        }</span><span style="font-size:small">
</span><span style="font-size:small">    );</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">behavior</span><span style="font-size:small">&amp; </span><span style="font-size:small">init_state</span><span style="font-size:small"> = </span><span style="font-size:small">empty</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">};</span></div>
<!--TOC subsubsection id=sec36 Nesting Receives Using <code>become</code><code>/</code><code>unbecome</code>-->
<h4 id="sec36" class="subsubsection">6.2.2  Nesting Receives Using <code>become</code><code>/</code><code>unbecome</code></h4><!--SEC END --><p>Nesting receives in an event-based actor is slightly more difficult compared to context-switching or thread-mapped actors, since <code>become</code> does not block.
An actor has to set a new behavior calling <code>become</code> with the <code>keep_behavior</code> policy to wait for the required message and then return to the previous behavior by using <code>unbecome</code>, as shown in the example below.</p><div class="lstlisting"><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// receives {int, float} sequences</span></span></span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">struct</span></span><span style="font-size:small"> </span><span style="font-size:small">testee</span><span style="font-size:small"> : </span><span style="font-size:small">event_based_actor</span><span style="font-size:small"> {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">void</span></span><span style="font-size:small"> </span><span style="font-size:small">init</span><span style="font-size:small">() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">become</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">      </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [=](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">value1</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">become</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">          </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// the keep_behavior policy stores the current behavior</span></span></span><span style="font-size:small">
</span><span style="font-size:small">          </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// on the behavior stack to be able to return to this</span></span></span><span style="font-size:small">
</span><span style="font-size:small">          </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// behavior later on by calling unbecome()</span></span></span><span style="font-size:small">
</span><span style="font-size:small">          </span><span style="font-size:small">keep_behavior</span><span style="font-size:small">,</span><span style="font-size:small">
</span><span style="font-size:small">          </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small">&gt;() &gt;&gt; [=](</span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small"> </span><span style="font-size:small">value2</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">cout</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">value1</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">" =&gt; "</span></span></span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">value2</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">endl</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// restore previous behavior</span></span></span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">unbecome</span><span style="font-size:small">();</span><span style="font-size:small">
</span><span style="font-size:small">          }</span><span style="font-size:small">
</span><span style="font-size:small">        );</span><span style="font-size:small">
</span><span style="font-size:small">      }</span><span style="font-size:small">
</span><span style="font-size:small">    );</span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">};</span></div><p>An event-based actor finishes execution with normal exit reason if the behavior stack is empty after calling <code>unbecome</code>.
The default policy of <code>become</code> is <code>discard_behavior</code> that causes an actor to override its current behavior.
The policy flag must be the first argument of <code>become</code>.</p>
<!--TOC subsubsection id=sec37 Using a Factory to Define Event-Based Actors-->
<h4 id="sec37" class="subsubsection">6.2.3  Using a Factory to Define Event-Based Actors</h4><!--SEC END --><p>
<a id="Sec::Receive::EventBased::Factory"></a></p><p>The previously introduced ways to define event-based actors always required a class definition.
A factory provides an ad-hoc way to define event-based actors using lambda expressions or other functors.
The factory <code>factory</code><code>::</code><code>event_based</code> takes a functor that is used as <code>event_based_actor</code><code>::</code><code>init</code> implementation.
Hence, the functor should call <code>become</code> to set an initial behavior.
Note that you have to call <code>self</code><code>-&gt;</code><code>become</code>, since <code>become</code> is not available via the <code><span style="color:blue">this</span></code> pointer.</p><p>Though <code>event_based_actor</code><code>::</code><code>init</code> has zero arguments, the functor can take any number of pointer arguments.
The factory then creates an actor with a member variable for each of those arguments and calls the functor with pointers to the actor’s member variables.
The member variables can be initialized with user-defined values passed to the <code>spawn</code> member function of the created factory, as shown in the following example.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">f</span><span style="font-size:small"> = </span><span style="font-size:small">factory</span><span style="font-size:small">::</span><span style="font-size:small">event_based</span><span style="font-size:small">([](</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">* </span><span style="font-size:small">name</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">self</span><span style="font-size:small">-&gt;</span><span style="font-size:small">become</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">        </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"get_name"</span></span></span><span style="font-size:small">)) &gt;&gt; [</span><span style="font-size:small">name</span><span style="font-size:small">]() {</span><span style="font-size:small">
</span><span style="font-size:small">            </span><span style="font-size:small">reply</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"name"</span></span></span><span style="font-size:small">), *</span><span style="font-size:small">name</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">        }</span><span style="font-size:small">
</span><span style="font-size:small">   );</span><span style="font-size:small">
</span><span style="font-size:small">});</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a1</span><span style="font-size:small"> = </span><span style="font-size:small">f</span><span style="font-size:small">.</span><span style="font-size:small">spawn</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"alice"</span></span></span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a2</span><span style="font-size:small"> = </span><span style="font-size:small">f</span><span style="font-size:small">.</span><span style="font-size:small">spawn</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"bob"</span></span></span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a3</span><span style="font-size:small"> = </span><span style="font-size:small">f</span><span style="font-size:small">.</span><span style="font-size:small">spawn</span><span style="font-size:small">(); </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// a3 has an empty name</span></span></span></div>
<!--TOC subsection id=sec38 Timeouts-->
<h3 id="sec38" class="subsection">6.3  Timeouts</h3><!--SEC END --><p>
<a id="Sec::Receive::Timeouts"></a></p><p>During receive, an actor is blocked until it dequeues a message from its mailbox that matches the given pattern.
If no such message ever arrives, the actor is blocked forever.
This might be desirable if the actor only provides a service and should not do anything else.
But often, we need to be able to recover if an expected messages does not arrive within a certain time period. The following examples illustrates the usage of <code>after</code> to define a timeout.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">#include</span></span><span style="font-size:small"> &lt;</span><span style="font-size:small">chrono</span><span style="font-size:small">&gt;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">#include</span></span><span style="font-size:small"> &lt;</span><span style="font-size:small">iostream</span><span style="font-size:small">&gt;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">using</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">cout</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">using</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">cerr</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">using</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">endl</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">receive</span><span style="font-size:small">(</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on_arg_match</span><span style="font-size:small"> &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/* ... */</span></span></span><span style="font-size:small"> },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on_arg_match</span><span style="font-size:small"> &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/* ... */</span></span></span><span style="font-size:small"> },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">others</span><span style="font-size:small">() &gt;&gt; []() { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/* ... */</span></span></span><span style="font-size:small"> },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">after</span><span style="font-size:small">(</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">chrono</span><span style="font-size:small">::</span><span style="font-size:small">seconds</span><span style="font-size:small">(10)) &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">cerr</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"received nothing within 10 seconds..."</span></span></span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">endl</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">receive</span><span style="font-size:small">(</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">after</span><span style="font-size:small">(</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">chrono</span><span style="font-size:small">::</span><span style="font-size:small">milliseconds</span><span style="font-size:small">(50)) &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">cerr</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"slept for 50ms"</span></span></span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">endl</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">receive</span><span style="font-size:small">(</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on_arg_match</span><span style="font-size:small"> &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">cout</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"found: "</span></span></span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">i</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">endl</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">  },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">after</span><span style="font-size:small">(</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">chrono</span><span style="font-size:small">::</span><span style="font-size:small">seconds</span><span style="font-size:small">(0)) &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">cout</span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"no integer found in mailbox"</span></span></span><span style="font-size:small"> &lt;&lt; </span><span style="font-size:small">endl</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div><p>Callbacks given as timeout handler must have zero arguments.
Any number of patterns can precede the timeout definition, but “<code>after</code>” must always be the final statement.
Using a zero-duration timeout causes <code>receive</code> to not block.</p><p><span style="font-family:monospace">libcppa</span> supports <code>minutes</code>, <code>seconds</code>, <code>milliseconds</code> and <code>microseconds</code>.
However, note that the precision depends on the operating system and your local work load.
Thus, you should not depend on a certain clock resolution.

</p>
<!--TOC section id=sec39 Synchronous Communication-->
<h2 id="sec39" class="section">7  Synchronous Communication</h2><!--SEC END --><p>
<a id="Sec::Sync"></a></p><p><span style="font-family:monospace">libcppa</span> uses a future-based API for synchronous communication.
The functions <code>sync_send</code> and <code>sync_send_tuple</code> send synchronous request messages to the receiver and return a future to the response message.
Note that the returned future is <span style="font-style:italic">actor-local</span>, i.e., only the actor that has send the corresponding request message is able to receive the response identified by such a future.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">template</span></span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">typename</span></span><span style="font-size:small">... </span><span style="font-size:small">Args</span><span style="font-size:small">&gt;</span><span style="font-size:small">
</span><span style="font-size:small">message_future</span><span style="font-size:small"> </span><span style="font-size:small">sync_send</span><span style="font-size:small">(</span><span style="font-size:small">actor_ptr</span><span style="font-size:small"> </span><span style="font-size:small">whom</span><span style="font-size:small">, </span><span style="font-size:small">Args</span><span style="font-size:small">&amp;&amp;... </span><span style="font-size:small">what</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">message_future</span><span style="font-size:small"> </span><span style="font-size:small">sync_send_tuple</span><span style="font-size:small">(</span><span style="font-size:small">actor_ptr</span><span style="font-size:small"> </span><span style="font-size:small">whom</span><span style="font-size:small">, </span><span style="font-size:small">any_tuple</span><span style="font-size:small"> </span><span style="font-size:small">what</span><span style="font-size:small">);</span></div><p>A synchronous message is sent to the receiving actor’s mailbox like any other asynchronous message.
The response message, on the other hand, is treated separately.</p><p><span style="font-weight:bold">Note:</span> the runtime system will automatically reply with an empty message if the receiving actor did not respond to a received synchronous response message by using the function <code>reply</code>.</p>
<!--TOC subsection id=sec40 Receive Response Messages-->
<h3 id="sec40" class="subsection">7.1  Receive Response Messages</h3><!--SEC END --><p>The functions <code>receive_response</code> and <code>handle_response</code> can be used to receive response messages, as shown in the following example.</p><div class="lstlisting"><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// an actor that replies with a string to atom("get")</span></span></span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">testee</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">&lt;</span><span style="font-size:small">testee_impl</span><span style="font-size:small">&gt;();</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// "receive_response" usage example (blocking API)</span></span></span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">future</span><span style="font-size:small"> = </span><span style="font-size:small">sync_send</span><span style="font-size:small">(</span><span style="font-size:small">testee</span><span style="font-size:small">, </span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"get"</span></span></span><span style="font-size:small">));</span><span style="font-size:small">
</span><span style="font-size:small">receive_response</span><span style="font-size:small"> (</span><span style="font-size:small">future</span><span style="font-size:small">) (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on_arg_match</span><span style="font-size:small"> &gt;&gt; [&amp;](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">str</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// handle str</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">after</span><span style="font-size:small">(</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">chrono</span><span style="font-size:small">::</span><span style="font-size:small">seconds</span><span style="font-size:small">(30)) &gt;&gt; [&amp;]() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// handle error</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// "handle_response" usage example (event-based API)</span></span></span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">future</span><span style="font-size:small"> = </span><span style="font-size:small">sync_send</span><span style="font-size:small">(</span><span style="font-size:small">testee</span><span style="font-size:small">, </span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"get"</span></span></span><span style="font-size:small">));</span><span style="font-size:small">
</span><span style="font-size:small">handle_response</span><span style="font-size:small"> (</span><span style="font-size:small">future</span><span style="font-size:small">) (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on_arg_match</span><span style="font-size:small"> &gt;&gt; [=](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">str</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// handle str</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">after</span><span style="font-size:small">(</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">chrono</span><span style="font-size:small">::</span><span style="font-size:small">seconds</span><span style="font-size:small">(30)) &gt;&gt; [=]() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// handle error</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div><p>The function <code>receive_response</code> is similar to <code>receive</code>, i.e., it blocks the calling actor until either a response message was received or a timeout occured.</p><p>Similar to <code>become</code>, the function <code>handle_response</code> is part of the event-based API and is used as “one-shot handler” to respond to a given future.
The behavior passed to <code>handle_response</code> is executed <span style="font-style:italic">once</span> and the actor automatically returns to its previous behavior afterwards.
It is possible to “stack” multiple <code>handle_response</code> calls.
Each response handler is executed once and then automatically discarded.</p><p>In both cases, the behavior definition of the response handler requires a timeout.</p>
<!--TOC subsection id=sec41 Using <code>message_future</code>’s Member Functions to Receive a Response-->
<h3 id="sec41" class="subsection">7.2  Using <code>message_future</code>’s Member Functions to Receive a Response</h3><!--SEC END --><p>Often, an actor sends a synchronous message and then wants to wait for the response.
In this case, using either <code>handle_response</code> or <code>receive_response</code> is quite verbose.
Therefore, <code>message_future</code> provides the two member functions <code>then</code> and <code>await</code>.
Using <code>then</code> is equal to using <code>handle_response</code>, wheres <code>await</code> corresponds to <code>receive_response</code>, as illustrated by the following example.</p><div class="lstlisting"><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// an actor that replies with a string to atom("get")</span></span></span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">testee</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">&lt;</span><span style="font-size:small">testee_impl</span><span style="font-size:small">&gt;();</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// receive response by using "await" (blocking API)</span></span></span><span style="font-size:small">
</span><span style="font-size:small">sync_send</span><span style="font-size:small">(</span><span style="font-size:small">testee</span><span style="font-size:small">, </span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"get"</span></span></span><span style="font-size:small">)).</span><span style="font-size:small">await</span><span style="font-size:small">(</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on_arg_match</span><span style="font-size:small"> &gt;&gt; [&amp;](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">str</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// handle str</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">after</span><span style="font-size:small">(</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">chrono</span><span style="font-size:small">::</span><span style="font-size:small">seconds</span><span style="font-size:small">(30)) &gt;&gt; [&amp;]() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// handle error</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// set response handler by using "then" (event-based API)</span></span></span><span style="font-size:small">
</span><span style="font-size:small">sync_send</span><span style="font-size:small">(</span><span style="font-size:small">testee</span><span style="font-size:small">, </span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"get"</span></span></span><span style="font-size:small">)).</span><span style="font-size:small">then</span><span style="font-size:small">(</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on_arg_match</span><span style="font-size:small"> &gt;&gt; [=](</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">str</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// handle str</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">after</span><span style="font-size:small">(</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">chrono</span><span style="font-size:small">::</span><span style="font-size:small">seconds</span><span style="font-size:small">(30)) &gt;&gt; [=]() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// handle error</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div>
<!--TOC section id=sec42 Management-->
<h2 id="sec42" class="section">8  Management</h2><!--SEC END --><p><span style="font-family:monospace">libcppa</span> adapts Erlang’s well-established fault propagation model.
It allows to build actor subsystem in which either all actors are alive or have collectively failed.</p>
<!--TOC subsection id=sec43 Links-->
<h3 id="sec43" class="subsection">8.1  Links</h3><!--SEC END --><p>Linked actors monitor each other.
An actor sends an exit message to all of its links as part of its termination.
The default behavior for actors receiving such an exit message is to die for the same reason, if the exit reason is non-normal.
Actors can <span style="font-style:italic">trap</span> exit messages to handle them manually.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">worker</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">(...);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// receive exit messages as regular messages</span></span></span><span style="font-size:small">
</span><span style="font-size:small">self</span><span style="font-size:small">-&gt;</span><span style="font-size:small">trap_exit</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:blue">true</span></span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// monitor spawned actor</span></span></span><span style="font-size:small">
</span><span style="font-size:small">self</span><span style="font-size:small">-&gt;</span><span style="font-size:small">link_to</span><span style="font-size:small">(</span><span style="font-size:small">worker</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// wait until worker exited</span></span></span><span style="font-size:small">
</span><span style="font-size:small">receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"EXIT"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">exit_reason</span><span style="font-size:small">::</span><span style="font-size:small">normal</span><span style="font-size:small">) &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// worker finished computation</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"EXIT"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">arg_match</span><span style="font-size:small">) &gt;&gt; [](</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">uint32_t</span><span style="font-size:small"> </span><span style="font-size:small">reason</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// worker died unexpectedly</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div>
<!--TOC subsection id=sec44 Monitors-->
<h3 id="sec44" class="subsection">8.2  Monitors</h3><!--SEC END --><p>A monitor observes the lifetime of an actor.
Monitored actors send a down message to all monitors as part of their termination.
Unlike exit messages, down messages are always treated like any other ordinary message.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">worker</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">(...);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// monitor spawned actor</span></span></span><span style="font-size:small">
</span><span style="font-size:small">self</span><span style="font-size:small">-&gt;</span><span style="font-size:small">monitor</span><span style="font-size:small">(</span><span style="font-size:small">worker</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// wait until worker exited</span></span></span><span style="font-size:small">
</span><span style="font-size:small">receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"DOWN"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">exit_reason</span><span style="font-size:small">::</span><span style="font-size:small">normal</span><span style="font-size:small">) &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// worker finished computation</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"DOWN"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">arg_match</span><span style="font-size:small">) &gt;&gt; [](</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">uint32_t</span><span style="font-size:small"> </span><span style="font-size:small">reason</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// worker died unexpectedly</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div><p>Monitors are redundant.
Hence, actors will receive one down message for each monitor.</p>
<!--TOC subsection id=sec45 Error Codes-->
<h3 id="sec45" class="subsection">8.3  Error Codes</h3><!--SEC END --><p>All error codes are defined in the namespace <code>cppa</code><code>::</code><code>exit_reason</code>.</p><table style="border-spacing:6px;border-collapse:separate;width:100%" class="cellpading0"><tr><td class="hbar" colspan=3></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" > <code>normal</code></td><td style="vertical-align:middle;text-align:left;" >1</td><td style="vertical-align:middle;text-align:left;" >Actor finished execution without error </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" > <code>unhandled_exception</code></td><td style="vertical-align:middle;text-align:left;" >2</td><td style="vertical-align:middle;text-align:left;" >Actor was killed due to an unhandled exception </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" > <code>unallowed_function_call</code></td><td style="vertical-align:middle;text-align:left;" >3</td><td style="vertical-align:middle;text-align:left;" >Indicates that an event-based actor tried to use blocking receive calls </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" > <code>remote_link_unreachable</code></td><td style="vertical-align:middle;text-align:left;" >257</td><td style="vertical-align:middle;text-align:left;" >Indicates that a remote actor became unreachable, e.g., due to connection error </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" > <code>user_defined</code></td><td style="vertical-align:middle;text-align:left;" >65536</td><td style="vertical-align:middle;text-align:left;" >Minimum value for user-defined exit codes </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
</table>
<!--TOC subsection id=sec46 Attach Cleanup Code to an Actor-->
<h3 id="sec46" class="subsection">8.4  Attach Cleanup Code to an Actor</h3><!--SEC END --><p>Actors can attach cleanup code to other actors.
This code is executed immediately if the actor has already exited.
Keep in mind that <code>self</code> refers to the currently running actor.
Thus, <code>self</code> refers to the terminating actor and not to the actor that attached a functor to it.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">worker</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">(...);</span><span style="font-size:small">
</span><span style="font-size:small">actor_ptr</span><span style="font-size:small"> </span><span style="font-size:small">observer</span><span style="font-size:small"> = </span><span style="font-size:small">self</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// "monitor" spawned actor</span></span></span><span style="font-size:small">
</span><span style="font-size:small">worker</span><span style="font-size:small">-&gt;</span><span style="font-size:small">attach_functor</span><span style="font-size:small">([</span><span style="font-size:small">observer</span><span style="font-size:small">](</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">uint32_t</span><span style="font-size:small"> </span><span style="font-size:small">reason</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// this callback is invoked from worker =&gt; self == worker</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">send</span><span style="font-size:small">(</span><span style="font-size:small">observer</span><span style="font-size:small">, </span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"DONE"</span></span></span><span style="font-size:small">));</span><span style="font-size:small">
</span><span style="font-size:small">});</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// wait until worker exited</span></span></span><span style="font-size:small">
</span><span style="font-size:small">receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"DONE"</span></span></span><span style="font-size:small">)) &gt;&gt; []() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// worker terminated</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div><p><span style="font-weight:bold">Note</span>: It is possible to attach code to remote actors, but the cleanup code will run on the local machine.

</p>
<!--TOC section id=sec47 Spawning Actors-->
<h2 id="sec47" class="section">9  Spawning Actors</h2><!--SEC END --><p>Actors are created using the function <code>spawn</code>.
The arguments passed to <code>spawn</code> depend on the actor’s implementation.</p>
<!--TOC subsection id=sec48 Create Actors from Functors-->
<h3 id="sec48" class="subsection">9.1  Create Actors from Functors</h3><!--SEC END --><p>The recommended way to implement both context-switching and thread-mapped actors is to use functors, e.g., a free function or lambda expression.
The arguments to the functor are passed to <code>spawn</code> as additional arguments.
The optional <code>scheduling_hint</code> template parameter of <code>spawn</code> decides whether an actor should run in its own thread or use context-switching.
The flag <code>detached</code> causes <code>spawn</code> to create a thread-mapped actor, whereas <code>scheduled</code>, the default flag, causes it to create a context-switching actor.
The function <code>spawn</code> provides a quite similar usage as <code>std</code><code>::</code><code>thread</code>, as shown in the examples below.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">#include</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"cppa/cppa.hpp"</span></span></span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">using</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">namespace</span></span><span style="font-size:small"> </span><span style="font-size:small">cppa</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">void</span></span><span style="font-size:small"> </span><span style="font-size:small">fun1</span><span style="font-size:small">();</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">void</span></span><span style="font-size:small"> </span><span style="font-size:small">fun2</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">arg1</span><span style="font-size:small">, </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small"> </span><span style="font-size:small">arg2</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">main</span><span style="font-size:small">() {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// spawn context-switching actors</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a1</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">(</span><span style="font-size:small">fun1</span><span style="font-size:small">); </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// equal to spawn&lt;scheduled&gt;(fun1)</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a2</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">(</span><span style="font-size:small">fun2</span><span style="font-size:small">, 42, </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"hello actor"</span></span></span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a3</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">&lt;</span><span style="font-size:small">scheduled</span><span style="font-size:small">&gt;(</span><span style="font-size:small">fun2</span><span style="font-size:small">, 42, </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"hello actor"</span></span></span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a4</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">([]() { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/* ... */</span></span></span><span style="font-size:small"> }); </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// spawn a lambda expression</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a5</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">([](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/* ... */</span></span></span><span style="font-size:small"> }, 42);</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// spawn thread-mapped actors</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a6</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">&lt;</span><span style="font-size:small">detached</span><span style="font-size:small">&gt;(</span><span style="font-size:small">fun1</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a7</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">&lt;</span><span style="font-size:small">detached</span><span style="font-size:small">&gt;([]() { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/* ... */</span></span></span><span style="font-size:small"> });</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a8</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">&lt;</span><span style="font-size:small">detached</span><span style="font-size:small">&gt;(</span><span style="font-size:small">fun2</span><span style="font-size:small">, 0, </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"zero"</span></span></span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">}</span></div><p>Though it is possible to subtype <code>context_switching_actor</code> to implement a class-based actor using context-switching, it is not recommended.
In general, context-switching and thread-mapped actors are intended to ease migration of existing applications or to implement managing actors on-the-fly using lambda expressions.
Class-based actors should be a subtype of <code>event_based_actor</code>, since this is the recommended actor implementation of <span style="font-family:monospace">libcppa</span>.</p><p><span style="font-weight:bold">Note</span>: <code>spawn</code><code>(</code><code>fun</code><code>, </code><code>arg0</code><code>, ...)</code> is <span style="font-style:italic">not</span> the same as <code>spawn</code><code>(</code><code>std</code><code>::</code><code>bind</code><code>(</code><code>fun</code><code>, </code><code>arg0</code><code>, ...))</code>!
For example, a call to <code>spawn</code><code>(</code><code>fun</code><code>, </code><code>self</code><code>, ...)</code> will pass a pointer to the calling actor to the newly created actor, as expected, whereas <code>spawn</code><code>(</code><code>std</code><code>::</code><code>bind</code><code>(</code><code>fun</code><code>, </code><code>self</code><code>, ...))</code> wraps the type of <code>self</code> into the function wrapper and evaluates <code>self</code> on function invocation.
Thus, the actor will end up having a pointer to itself rather than a pointer to the actor that created it.</p>
<!--TOC subsection id=sec49 Create Class-Based Actors-->
<h3 id="sec49" class="subsection">9.2  Create Class-Based Actors</h3><!--SEC END --><p>Spawning class-based actors is straightforward and uses the function <code>spawn</code> as well.
The template parameter is the implementing class rather than a <code>scheduling_hint</code>, since class-based actors are always scheduled.
All arguments are forwarded to the constructor, as shown in the following example.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">#include</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"cppa/cppa.hpp"</span></span></span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">using</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">namespace</span></span><span style="font-size:small"> </span><span style="font-size:small">cppa</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">class</span></span><span style="font-size:small"> </span><span style="font-size:small">my_actor1</span><span style="font-size:small"> : </span><span style="font-size:small"><span style="color:blue">public</span></span><span style="font-size:small"> </span><span style="font-size:small">event_based_actor</span><span style="font-size:small"> { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/* ... */</span></span></span><span style="font-size:small"> };</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">class</span></span><span style="font-size:small"> </span><span style="font-size:small">my_actor2</span><span style="font-size:small"> : </span><span style="font-size:small"><span style="color:blue">public</span></span><span style="font-size:small"> </span><span style="font-size:small">sb_actor</span><span style="font-size:small">&lt;</span><span style="font-size:small">my_actor2</span><span style="font-size:small">&gt; {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/* ... */</span></span></span><span style="font-size:small">
</span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">public</span></span><span style="font-size:small">:</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">my_actor2</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">value1</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small"> </span><span style="font-size:small">value</span><span style="font-size:small"> 2) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">};</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">main</span><span style="font-size:small">() {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a1</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">&lt;</span><span style="font-size:small">my_actor1</span><span style="font-size:small">&gt;();</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a2</span><span style="font-size:small"> = </span><span style="font-size:small">spawn</span><span style="font-size:small">&lt;</span><span style="font-size:small">my_actor2</span><span style="font-size:small">&gt;(1, 2.0</span><span style="font-size:small">f</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">}</span></div><p>For spawning event-based actors without implementing an own class see Section <a href="#Sec%3A%3AReceive%3A%3AEventBased%3A%3AFactory">6.2.3</a>.
To spawn actors as members of a group see Section <a href="#Sec%3A%3AGroup%3A%3ASpawn">11.3</a>.

</p>
<!--TOC section id=sec50 Network Transparency-->
<h2 id="sec50" class="section">10  Network Transparency</h2><!--SEC END --><p>All actor operations as well as sending messages are network transparent.
Remote actors are represented by actor proxies that forward all messages.</p>
<!--TOC subsection id=sec51 Publishing of Actors-->
<h3 id="sec51" class="subsection">10.1  Publishing of Actors</h3><!--SEC END --><div class="lstlisting"><span style="font-size:small"><span style="color:blue">void</span></span><span style="font-size:small"> </span><span style="font-size:small">publish</span><span style="font-size:small">(</span><span style="font-size:small">actor_ptr</span><span style="font-size:small"> </span><span style="font-size:small">whom</span><span style="font-size:small">, </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">uint16_t</span><span style="font-size:small"> </span><span style="font-size:small">port</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">char</span></span><span style="font-size:small">* </span><span style="font-size:small">addr</span><span style="font-size:small"> = 0)</span></div><p>The function <code>publish</code> binds an actor to a given port.
It throws <code>network_error</code> if socket related errors occur or <code>bind_failure</code> if the specified port is already in use.
The optional <code>addr</code> parameter can be used to listen only to the given IP address.
Otherwise, the actor accepts all incoming connections (<code>INADDR_ANY</code>).</p><div class="lstlisting"><span style="font-size:small">publish</span><span style="font-size:small">(</span><span style="font-size:small">self</span><span style="font-size:small">, 4242);</span><span style="font-size:small">
</span><span style="font-size:small">receive_loop</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"ping"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">arg_match</span><span style="font-size:small">) &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">reply</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"pong"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">i</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">);</span></div>
<!--TOC subsection id=sec52 Connecting to Remote Actors-->
<h3 id="sec52" class="subsection">10.2  Connecting to Remote Actors</h3><!--SEC END --><div class="lstlisting"><span style="font-size:small">actor_ptr</span><span style="font-size:small"> </span><span style="font-size:small">remote_actor</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">char</span></span><span style="font-size:small">* </span><span style="font-size:small">host</span><span style="font-size:small">, </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">uint16_t</span><span style="font-size:small"> </span><span style="font-size:small">port</span><span style="font-size:small">)</span></div><p>The function <code>remote_actor</code> connects to the actor at given host and port.
A <code>network_error</code> is thrown if the connection failed.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">pong</span><span style="font-size:small"> = </span><span style="font-size:small">remote_actor</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"localhost"</span></span></span><span style="font-size:small">, 4242);</span><span style="font-size:small">
</span><span style="font-size:small">send</span><span style="font-size:small">(</span><span style="font-size:small">pong</span><span style="font-size:small">, </span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"ping"</span></span></span><span style="font-size:small">), 0);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">bool</span></span><span style="font-size:small"> </span><span style="font-size:small">done</span><span style="font-size:small"> = </span><span style="font-size:small"><span style="color:blue">false</span></span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">do_receive</span><span style="font-size:small"> (</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"pong"</span></span></span><span style="font-size:small">), 10) &gt;&gt; [&amp;]() {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">done</span><span style="font-size:small"> = </span><span style="font-size:small"><span style="color:blue">true</span></span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">  },</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">on</span><span style="font-size:small">&lt;</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"pong"</span></span></span><span style="font-size:small">), </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;() &gt;&gt; [](</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small">) {</span><span style="font-size:small">
</span><span style="font-size:small">    </span><span style="font-size:small">reply</span><span style="font-size:small">(</span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"ping"</span></span></span><span style="font-size:small">), </span><span style="font-size:small">i</span><span style="font-size:small">+1);</span><span style="font-size:small">
</span><span style="font-size:small">  }</span><span style="font-size:small">
</span><span style="font-size:small">).</span><span style="font-size:small">until</span><span style="font-size:small">(</span><span style="font-size:small">gref</span><span style="font-size:small">(</span><span style="font-size:small">done</span><span style="font-size:small">));</span></div>
<!--TOC section id=sec53 Group Communication-->
<h2 id="sec53" class="section">11  Group Communication</h2><!--SEC END --><p>
<a id="Sec::Group"></a></p><p><span style="font-family:monospace">libcppa</span> supports publish/subscribe-based group communication.
Actors can join and leave groups and send messages to groups.</p><div class="lstlisting"><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small"> </span><span style="font-size:small">group_module</span><span style="font-size:small"> = ...;</span><span style="font-size:small">
</span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small"> </span><span style="font-size:small">group_id</span><span style="font-size:small"> = ...;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">grp</span><span style="font-size:small"> = </span><span style="font-size:small">group</span><span style="font-size:small">::</span><span style="font-size:small">get</span><span style="font-size:small">(</span><span style="font-size:small">group_module</span><span style="font-size:small">, </span><span style="font-size:small">group_id</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">self</span><span style="font-size:small">-&gt;</span><span style="font-size:small">join</span><span style="font-size:small">(</span><span style="font-size:small">grp</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">send</span><span style="font-size:small">(</span><span style="font-size:small">grp</span><span style="font-size:small">, </span><span style="font-size:small">atom</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"test"</span></span></span><span style="font-size:small">));</span><span style="font-size:small">
</span><span style="font-size:small">self</span><span style="font-size:small">-&gt;</span><span style="font-size:small">leave</span><span style="font-size:small">(</span><span style="font-size:small">grp</span><span style="font-size:small">);</span></div>
<!--TOC subsection id=sec54 Anonymous Groups-->
<h3 id="sec54" class="subsection">11.1  Anonymous Groups</h3><!--SEC END --><p>
<a id="Sec::Group::Anonymous"></a></p><p>Groups created on-the-fly with <code>group</code><code>::</code><code>anonymous</code><code>()</code> can be used to coordinate a set of workers.
Each call to <code>group</code><code>::</code><code>anonymous</code><code>()</code> returns a new group instance.</p>
<!--TOC subsection id=sec55 Local Groups-->
<h3 id="sec55" class="subsection">11.2  Local Groups</h3><!--SEC END --><p>
<a id="Sec::Group::Local"></a></p><p>The <code><span style="color:#007F00"><code>"local"</code></span></code> group module creates groups for in-process communication.
For example, a group for GUI related events could be identified by <code>group</code><code>::</code><code>get</code><code>(</code><code><span style="color:#007F00"><code>"local"</code></span></code><code>, </code><code><span style="color:#007F00"><code>"GUI events"</code></span></code><code>)</code>.
The group ID <code><span style="color:#007F00"><code>"GUI events"</code></span></code> uniquely identifies a singleton group instance of the module <code><span style="color:#007F00"><code>"local"</code></span></code>.</p>
<!--TOC subsection id=sec56 Spawn Actors in Groups-->
<h3 id="sec56" class="subsection">11.3  Spawn Actors in Groups</h3><!--SEC END --><p>
<a id="Sec::Group::Spawn"></a></p><p>The function <code>spawn_in_group</code> can be used to create actors as members of a group.
The function causes the newly created actors to call <code>self</code><code>-&gt;</code><code>join</code><code>(...)</code> immediately and before <code>spawn_in_group</code> returns. 
The usage of <code>spawn_in_group</code> is equal to <code>spawn</code>, except for an additional group argument.
The group handle is always the first argument, as shown in the examples below.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">void</span></span><span style="font-size:small"> </span><span style="font-size:small">fun1</span><span style="font-size:small">();</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">void</span></span><span style="font-size:small"> </span><span style="font-size:small">fun2</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:blue">float</span></span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">class</span></span><span style="font-size:small"> </span><span style="font-size:small">my_actor1</span><span style="font-size:small"> : </span><span style="font-size:small">event_based_actor</span><span style="font-size:small"> { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/* ... */</span></span></span><span style="font-size:small"> };</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">class</span></span><span style="font-size:small"> </span><span style="font-size:small">my_actor2</span><span style="font-size:small"> : </span><span style="font-size:small">event_based_actor</span><span style="font-size:small"> {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">my_actor2</span><span style="font-size:small">(</span><span style="font-size:small"><span style="color:blue">const</span></span><span style="font-size:small"> </span><span style="font-size:small">std</span><span style="font-size:small">::</span><span style="font-size:small">string</span><span style="font-size:small">&amp; </span><span style="font-size:small">str</span><span style="font-size:small">) { </span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">/* ... */</span></span></span><span style="font-size:small"> }</span><span style="font-size:small">
</span><span style="font-size:small">};</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// ...</span></span></span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">grp</span><span style="font-size:small"> = </span><span style="font-size:small">group</span><span style="font-size:small">::</span><span style="font-size:small">get</span><span style="font-size:small">(...);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a1</span><span style="font-size:small"> = </span><span style="font-size:small">spawn_in_group</span><span style="font-size:small">(</span><span style="font-size:small">grp</span><span style="font-size:small">, </span><span style="font-size:small">fun1</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a2</span><span style="font-size:small"> = </span><span style="font-size:small">spawn_in_group</span><span style="font-size:small">(</span><span style="font-size:small">grp</span><span style="font-size:small">, </span><span style="font-size:small">fun2</span><span style="font-size:small">, 1, 2.0</span><span style="font-size:small">f</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a3</span><span style="font-size:small"> = </span><span style="font-size:small">spawn_in_group</span><span style="font-size:small">&lt;</span><span style="font-size:small">my_actor1</span><span style="font-size:small">&gt;(</span><span style="font-size:small">grp</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">auto</span></span><span style="font-size:small"> </span><span style="font-size:small">a4</span><span style="font-size:small"> = </span><span style="font-size:small">spawn_in_group</span><span style="font-size:small">&lt;</span><span style="font-size:small">my_actor2</span><span style="font-size:small">&gt;(</span><span style="font-size:small">grp</span><span style="font-size:small">, </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"hello my_actor2!"</span></span></span><span style="font-size:small">);</span></div>
<!--TOC section id=sec57 Common Pitfalls-->
<h2 id="sec57" class="section">12  Common Pitfalls</h2><!--SEC END --><p>
<a id="Sec::Pitfalls"></a></p>
<!--TOC subsection id=sec58 Event-Based API-->
<h3 id="sec58" class="subsection">12.1  Event-Based API</h3><!--SEC END --><ul class="itemize"><li class="li-itemize">
The functions <code>become</code> and <code>handle_response</code> do not block, i.e., always return immediately.
Thus, you should <span style="font-style:italic">always</span> capture by value in event-based actors, because all references on the stack will cause undefined behavior if a lambda is executed.
</li></ul>
<!--TOC subsection id=sec59 Mixing Event-Based and Blocking API-->
<h3 id="sec59" class="subsection">12.2  Mixing Event-Based and Blocking API</h3><!--SEC END --><ul class="itemize"><li class="li-itemize">
Blocking <span style="font-family:monospace">libcppa</span> function such as <code>receive</code> will <span style="font-weight:bold">throw an exception</span> if accessed from an event-based actor.
To catch as many errors as possible at compile-time, <span style="font-family:monospace">libcppa</span> will produce an error if <code>receive</code> is called and the <code><span style="color:blue">this</span></code> pointer is set and points to an event-based actor.</li><li class="li-itemize">Context-switching and thread-mapped actors <span style="font-style:italic">can</span> use the <code>become</code> API, <span style="font-weight:bold">but</span> they should use it either exclusively or not at all.
Whenever a non-event-based actor calls <code>become</code><code>()</code> for the first time, it will create a behavior stack and execute it until the behavior stack is empty.
Thus, the <span style="font-style:italic">initial</span> <code>become</code> <span style="font-style:italic">blocks</span> until the behavior stack is empty, whereas all subsequent calls to <code>become</code> will return immediately.
Related functions, e.g., <code>sync_send</code><code>(...).</code><code>then</code><code>(...)</code>, behave the same, as they manipulate the behavior as well.
</li></ul>
<!--TOC subsection id=sec60 Synchronous Messages-->
<h3 id="sec60" class="subsection">12.3  Synchronous Messages</h3><!--SEC END --><ul class="itemize"><li class="li-itemize"><code>send</code><code>(</code><code>self</code><code>-&gt;</code><code>last_sender</code><code>(), ...)</code> is <span style="font-weight:bold">not</span> equal to <code>reply</code><code>(...)</code>.
The two functions <code>receive_response</code> and <code>handle_response</code> will only recognize messages send via either <code>reply</code> or <code>reply_tuple</code>.</li><li class="li-itemize">A future returned by <code>sync_send</code> represents <em>exactly one</em> response message.
Therefore, it is not possible to receive more than one response message.
Calling <code>reply</code> more than once will result in lost messages and calling <code>handle_response</code> or <code>receive_response</code> more than once on a future will throw an exception.</li><li class="li-itemize">The future returned by <code>sync_send</code> is bound to the calling actor.
It is not possible to transfer such a future to another actor.
Calling <code>receive_response</code> or <code>handle_response</code> for a future bound to another actor is undefined behavior.</li></ul>
<!--TOC subsection id=sec61 Sending Messages-->
<h3 id="sec61" class="subsection">12.4  Sending Messages</h3><!--SEC END --><ul class="itemize"><li class="li-itemize"><code>send</code><code>(</code><code>whom</code><code>, ...)</code> is syntactic sugar for <code>whom</code><code> &lt;&lt; </code><code>make_any_tuple</code><code>(...)</code>.
Hence, a message sent via <code>send</code><code>(</code><code>whom</code><code>, </code><code>self</code><code>-&gt;</code><code>last_dequeued</code><code>())</code> will not yield the expected result, since it wraps <code>self</code><code>-&gt;</code><code>last_dequeued</code><code>()</code> into another <code>any_tuple</code> instance.
The correct way of forwarding messages is <code>self</code><code>-&gt;</code><code>forward_to</code><code>(</code><code>whom</code><code>)</code>.</li></ul>
<!--TOC subsection id=sec62 Sharing-->
<h3 id="sec62" class="subsection">12.5  Sharing</h3><!--SEC END --><ul class="itemize"><li class="li-itemize">
It is strongly recommended to <span style="font-weight:bold">not</span> share states between actors.
In particular, no actor shall ever access member variables or member functions of another actor.
Accessing shared memory segments concurrently can cause undefined behavior that is incredibly hard to find and debug.
However, sharing <span style="font-style:italic">data</span> between actors is fine, as long as the data is <span style="font-style:italic">immutable</span> and all actors access the data only via smart pointers such as <code>std</code><code>::</code><code>shared_ptr</code>.
Nevertheless, the recommended way of sharing informations is message passing.
Sending data to multiple actors does <span style="font-style:italic">not</span> result in copying the data several times.
Read Section <a href="#Sec%3A%3ATuples">2</a> to learn more about <span style="font-family:monospace">libcppa</span>’s copy-on-write optimization for tuples.
</li></ul>
<!--TOC section id=sec63 Platform-Independent Type System-->
<h2 id="sec63" class="section">13  Platform-Independent Type System</h2><!--SEC END --><p>
<a id="Sec::TypeSystem"></a></p><p><span style="font-family:monospace">libcppa</span> provides a fully network transparent communication between actors.
Thus, <span style="font-family:monospace">libcppa</span> needs to serialize and deserialize messages.
Unfortunately, this is not possible using the RTTI system of C++.
<span style="font-family:monospace">libcppa</span> uses its own RTTI based on the class <code>uniform_type_info</code>, since it is not possible to extend <code>std</code><code>::</code><code><span style="color:blue">type_info</span></code>.</p><p>Unlike <code>std</code><code>::</code><code><span style="color:blue">type_info</span></code><code>::</code><code>name</code><code>()</code>, <code>uniform_type_info</code><code>::</code><code>name</code><code>()</code> is guaranteed to return the same name on all supported platforms. Furthermore, it allows to create an instance of a type by name.</p><div class="lstlisting"><span style="font-size:small"><span style="color:#7F007F"><span style="font-size:small">// creates a signed, 32 bit integer</span></span></span><span style="font-size:small">
</span><span style="font-size:small">cppa</span><span style="font-size:small">::</span><span style="font-size:small">object</span><span style="font-size:small"> </span><span style="font-size:small">i</span><span style="font-size:small"> = </span><span style="font-size:small">cppa</span><span style="font-size:small">::</span><span style="font-size:small">uniform_typeid</span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small">&gt;()-&gt;</span><span style="font-size:small">create</span><span style="font-size:small">();</span></div><p>However, you should rarely if ever need to use <code>object</code> or <code>uniform_type_info</code>.</p>
<!--TOC subsection id=sec64 User-Defined Data Types in Messages-->
<h3 id="sec64" class="subsection">13.1  User-Defined Data Types in Messages</h3><!--SEC END --><p>
<a id="Sec::TypeSystem::UserDefined"></a></p><p>All user-defined types must be explicitly “announced” so that <span style="font-family:monospace">libcppa</span> can (de)serialize them correctly, as shown in the example below.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">#include</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:#007F00"><span style="font-size:small">"cppa/cppa.hpp"</span></span></span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">using</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="color:blue">namespace</span></span><span style="font-size:small"> </span><span style="font-size:small">cppa</span><span style="font-size:small">;</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">struct</span></span><span style="font-size:small"> </span><span style="font-size:small">foo</span><span style="font-size:small"> { </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">a</span><span style="font-size:small">; </span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">b</span><span style="font-size:small">; };</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">int</span></span><span style="font-size:small"> </span><span style="font-size:small">main</span><span style="font-size:small">() {</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">announce</span><span style="font-size:small">&lt;</span><span style="font-size:small">foo</span><span style="font-size:small">&gt;(&amp;</span><span style="font-size:small">foo</span><span style="font-size:small">::</span><span style="font-size:small">a</span><span style="font-size:small">, &amp;</span><span style="font-size:small">foo</span><span style="font-size:small">::</span><span style="font-size:small">b</span><span style="font-size:small">);</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small">send</span><span style="font-size:small">(</span><span style="font-size:small">self</span><span style="font-size:small">, </span><span style="font-size:small">foo</span><span style="font-size:small">{1,2});</span><span style="font-size:small">
</span><span style="font-size:small">  </span><span style="font-size:small"><span style="color:blue">return</span></span><span style="font-size:small"> 0;</span><span style="font-size:small">
</span><span style="font-size:small">}</span></div><p>Without the <code>announce</code> function call, the example program would terminate with an exception, because <span style="font-family:monospace">libcppa</span> rejects all types without available runtime type information.</p><p><code>announce</code><code>()</code> takes the class as template parameter and pointers to all members (or getter/setter pairs) as arguments.
This works for all primitive data types and STL compliant containers.
See the announce examples 1 – 4 of the standard distribution for more details.</p><p>Obviously, there are limitations.
You have to implement serialize/deserialize by yourself if your class does implement an unsupported data structure.
See <code>announce_example_5</code><code>.</code><code>cpp</code> in the examples folder.
</p>
<!--TOC section id=sec65 Appendix-->
<h2 id="sec65" class="section">14  Appendix</h2><!--SEC END -->
<!--TOC subsection id=sec66 Class <code>option</code>-->
<h3 id="sec66" class="subsection">14.1  Class <code>option</code></h3><!--SEC END --><p>
<a id="Appendix::Option"></a></p><p>Defined in header <code><span style="color:#007F00"><code>"cppa/option.hpp"</code></span></code>.</p><div class="lstlisting"><span style="font-size:small"><span style="color:blue">template</span></span><span style="font-size:small">&lt;</span><span style="font-size:small"><span style="color:blue">typename</span></span><span style="font-size:small"> </span><span style="font-size:small">T</span><span style="font-size:small">&gt;</span><span style="font-size:small">
</span><span style="font-size:small"><span style="color:blue">class</span></span><span style="font-size:small"> </span><span style="font-size:small">option</span><span style="font-size:small">;</span></div><p>Represents an optional value.</p><table style="border-spacing:6px;border-collapse:separate;width:100%" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap"  colspan=2><span style="font-size:large"><span style="font-weight:bold">Member types</span></span><span style="font-size:small"> </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><span style="font-size:small"><span style="font-weight:bold">Member type</span></span></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"><span style="font-weight:bold">Definition</span></span><span style="font-size:small"> </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small">type</span></code></td><td style="vertical-align:middle;text-align:left;" ><code><span style="font-size:small">T</span></code><span style="font-size:small"> </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap"  colspan=2><span style="font-size:large"><span style="font-weight:bold">Member functions</span></span><span style="font-size:small"> </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small">option</span></code><code><span style="font-size:small">()</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Constructs an empty option </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small">option</span></code><code><span style="font-size:small">(</span></code><code><span style="font-size:small">T</span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">value</span></code><code><span style="font-size:small">)</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Initializes </span><code><span style="font-size:small"><span style="color:blue">this</span></span></code><span style="font-size:small"> with </span><code><span style="font-size:small">value</span></code><span style="font-size:small"> </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small">option</span></code><code><span style="font-size:small">(</span></code><code><span style="font-size:small"><span style="color:blue">const</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">option</span></code><code><span style="font-size:small">&amp;)</span></code><span style="font-size:small"><br>
</span><code><span style="font-size:small">option</span></code><code><span style="font-size:small">(</span></code><code><span style="font-size:small">option</span></code><code><span style="font-size:small">&amp;&amp;)</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Copy/move construction </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small">option</span></code><code><span style="font-size:small">&amp; </span></code><code><span style="font-size:small"><span style="color:blue">operator</span></span></code><code><span style="font-size:small">=(</span></code><code><span style="font-size:small"><span style="color:blue">const</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">option</span></code><code><span style="font-size:small">&amp;)</span></code><span style="font-size:small"><br>
</span><code><span style="font-size:small">option</span></code><code><span style="font-size:small">&amp; </span></code><code><span style="font-size:small"><span style="color:blue">operator</span></span></code><code><span style="font-size:small">=(</span></code><code><span style="font-size:small">option</span></code><code><span style="font-size:small">&amp;&amp;)</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Copy/move assignment </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap"  colspan=2><span style="font-size:small"><span style="font-weight:bold">Observers</span></span><span style="font-size:small"> </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small"><span style="color:blue">bool</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">valid</span></code><code><span style="font-size:small">()</span></code><span style="font-size:small"><br>
</span><code><span style="font-size:small"><span style="color:blue">explicit</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small"><span style="color:blue">operator</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small"><span style="color:blue">bool</span></span></code><code><span style="font-size:small">()</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Returns </span><code><span style="font-size:small"><span style="color:blue">true</span></span></code><span style="font-size:small"> if </span><code><span style="font-size:small"><span style="color:blue">this</span></span></code><span style="font-size:small"> has a value </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small"><span style="color:blue">bool</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">empty</span></code><code><span style="font-size:small">()</span></code><span style="font-size:small"><br>
</span><code><span style="font-size:small"><span style="color:blue">bool</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small"><span style="color:blue">operator</span></span></code><code><span style="font-size:small">!()</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Returns </span><code><span style="font-size:small"><span style="color:blue">true</span></span></code><span style="font-size:small"> if </span><code><span style="font-size:small"><span style="color:blue">this</span></span></code><span style="font-size:small"> does </span><span style="font-size:small"><span style="font-weight:bold">not</span></span><span style="font-size:small"> has a value </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small"><span style="color:blue">const</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">T</span></code><code><span style="font-size:small">&amp; </span></code><code><span style="font-size:small">get</span></code><code><span style="font-size:small">()</span></code><span style="font-size:small"><br>
</span><code><span style="font-size:small"><span style="color:blue">const</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">T</span></code><code><span style="font-size:small">&amp; </span></code><code><span style="font-size:small"><span style="color:blue">operator</span></span></code><code><span style="font-size:small">*()</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Access stored value </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small"><span style="color:blue">const</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">T</span></code><code><span style="font-size:small">&amp; </span></code><code><span style="font-size:small">get_or_else</span></code><code><span style="font-size:small">(</span></code><code><span style="font-size:small"><span style="color:blue">const</span></span></code><code><span style="font-size:small"> </span></code><code><span style="font-size:small">T</span></code><code><span style="font-size:small">&amp; </span></code><code><span style="font-size:small">x</span></code><code><span style="font-size:small">)</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Returns </span><code><span style="font-size:small">get</span></code><code><span style="font-size:small">()</span></code><span style="font-size:small"> if valid, </span><code><span style="font-size:small">x</span></code><span style="font-size:small"> otherwise </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap"  colspan=2><span style="font-size:small"><span style="font-weight:bold">Modifiers</span></span><span style="font-size:small"> </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small"> </span><code><span style="font-size:small">T</span></code><code><span style="font-size:small">&amp; </span></code><code><span style="font-size:small">get</span></code><code><span style="font-size:small">()</span></code><span style="font-size:small"><br>
</span><code><span style="font-size:small">T</span></code><code><span style="font-size:small">&amp; </span></code><code><span style="font-size:small"><span style="color:blue">operator</span></span></code><code><span style="font-size:small">*()</span></code></td><td style="vertical-align:middle;text-align:left;" ><span style="font-size:small">Access stored value </span></td></tr>
<tr><td class="hbar" colspan=2><span style="font-size:small"></span></td></tr>
</table><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</em><a href="http://hevea.inria.fr/index.html"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a><em>.</em></blockquote></body>
</html>
